// Refactored ScrollableTable - Production Ready
import * as React from "react";
import ReactDOMServer from "react-dom/server";
import {
  Typography,
  Table,
  TableContainer,
  TableBody,
  TableRow,
  TableCell,
  Box,
  Paper,
  Checkbox,
  CircularProgress,
} from "@mui/material";
import styles from "./style.module.scss";
import { Order, PaginatedTableProps } from "./table.d";
import EnhancedTableHead from "./head";
import Row from "./collapsible_row";
import { getComparator, getSum, stableSort } from "./helpers";
import HtmlTable from "./html_table";
import NoData from "./NoData";
import { useRouter } from "next/router";

const ScrollableTable = (props: PaginatedTableProps) => {
  const [order, setOrder] = React.useState<Order>("asc");
  const [orderBy, setOrderBy] = React.useState<string>("");
  const [totalColSpan, setTotalColSpan] = React.useState<any>(0);
  const [htmlTable, setHtmlTable] = React.useState<any>("");
  const [isPrintClicked, setPrintClicked] = React.useState<boolean>(false);
  const [isExcelClicked, setExcelClicked] = React.useState<boolean>(false);
  const [expandedRowId, setExpandedRowId] = React.useState<string | null>(null);

  // Infinite scroll state
  const [visibleCount, setVisibleCount] = React.useState(10);
  const [isLocalLoading, setIsLocalLoading] = React.useState(false);
  
  // Refs
  const isMountedRef = React.useRef(true);
  const loaderRef = React.useRef<HTMLDivElement | null>(null);
  const tableContainerRef = React.useRef<HTMLDivElement | null>(null);
  const observerRef = React.useRef<IntersectionObserver | null>(null);
  const scrollPositionRef = React.useRef<number>(0);
  const isLoadingRef = React.useRef<boolean>(false);
  const lastLoadTimeRef = React.useRef<number>(0);

  const router = useRouter();
  const { locale } = router;

  const {
    expandable,
    expandInCols,
    serialNo,
    rows,
    headCells,
    expandIconAt,
    uniqueKey,
    actions,
    loading,
    tableRef,
    tableTitle,
    excelFileName,
    order: orderProps,
    orderBy: orderByProps,
    showTotal,
    selectable,
    selected,
    setSelected,
    viewlabel,
    coloumnNumber,
    agentNumber,
    hasMore = false,
    onLoadMore,
    totalLength,
    isLoadingMore = false,
    onScrollPositionChange,
  } = props;

  const lengthOfData = rows?.length || 0;

  // Save and restore scroll position functions
  const saveScrollPosition = React.useCallback(() => {
    if (tableContainerRef.current) {
      scrollPositionRef.current = tableContainerRef.current.scrollTop;
      console.log('Scroll position saved:', scrollPositionRef.current);
    }
  }, []);

  const restoreScrollPosition = React.useCallback(() => {
    if (tableContainerRef.current && scrollPositionRef.current > 0) {
      // Use RAF for smooth restoration after DOM updates
      requestAnimationFrame(() => {
        requestAnimationFrame(() => {
          if (tableContainerRef.current) {
            tableContainerRef.current.scrollTop = scrollPositionRef.current;
            console.log('Scroll position restored:', scrollPositionRef.current);
          }
        });
      });
    }
  }, []);

  // Expose scroll handlers to parent
  React.useEffect(() => {
    if (onScrollPositionChange) {
      onScrollPositionChange({
        saveScrollPosition,
        restoreScrollPosition
      });
    }
  }, [onScrollPositionChange, saveScrollPosition, restoreScrollPosition]);

  const handleToggleExpand = (rowId: string) => {
    setExpandedRowId(prev => (prev === rowId ? null : rowId));
  };

  // Colspan setup
  React.useEffect(() => {
    setTotalColSpan(
      1 +
        (selectable ? 1 : 0) +
        (serialNo ? 1 : 0) +
        (expandIconAt === "start" ? 1 : 0)
    );
  }, [showTotal, selectable, serialNo, expandIconAt]);

  // External order props
  React.useEffect(() => {
    if (orderProps) setOrder(orderProps);
  }, [orderProps]);

  React.useEffect(() => {
    if (orderByProps) setOrderBy(orderByProps);
  }, [orderByProps]);

  // Export logic
  React.useEffect(() => {
    if (headCells && rows.length > 0) {
      const htmlTableSample = ReactDOMServer.renderToString(
        <HtmlTable
          headCells={headCells}
          rows={rows}
          uniqueKey={`row-${uniqueKey}-${rows[0]}`}
          title={tableTitle}
        />
      );
      setHtmlTable(htmlTableSample);
    }
  }, [rows, headCells, uniqueKey, tableTitle]);

  const base64 = (s: any) => window.btoa(unescape(encodeURIComponent(s)));
  
  React.useEffect(() => {
    if (isPrintClicked) {
      const printWindow = window.open("", "", "width=800,height=600");
      if (printWindow) {
        printWindow.document.write(htmlTable);
        printWindow.document.close();
        setTimeout(() => {
          printWindow.focus();
          printWindow.print();
          setPrintClicked(false);
        }, 500);
      }
    }
  }, [isPrintClicked, htmlTable]);

  React.useEffect(() => {
    if (isExcelClicked) {
      const uri = "data:application/vnd.ms-excel;base64,";
      const template = `<html xmlns:o="urn:schemas-microsoft-com:office:office" 
        xmlns:x="urn:schemas-microsoft-com:office:excel" 
        xmlns="http://www.w3.org/TR/REC-html40">
        <head><meta http-equiv="content-type" content="text/plain; charset=UTF-8"/></head>
        <body>${htmlTable}</body></html>`;
      const a = window.document.createElement("a");
      a.href = uri + base64(template);
      a.download = `${excelFileName}.xls`;
      a.click();
      setExcelClicked(false);
    }
  }, [isExcelClicked, htmlTable, excelFileName]);

  const print = React.useCallback(() => setPrintClicked(true), []);
  const exportToExcel = React.useCallback(() => setExcelClicked(true), []);

  React.useEffect(() => {
    if (tableRef) {
      tableRef.current = { print, exportToExcel };
    }
  }, [tableRef, print, exportToExcel]);

  const handleRequestSort = (
    event: React.MouseEvent<unknown>,
    property: string
  ) => {
    const isAsc = orderBy === property && order === "asc";
    setOrder(isAsc ? "desc" : "asc");
    setOrderBy(property);
  };

  const handleSelectAllClick = (event: any) => {
    if (event.target.checked) {
      const newSelecteds = rows.map(n => n[uniqueKey].toString());
      setSelected && setSelected(newSelecteds);
      return;
    }
    setSelected && setSelected([]);
  };

  const handleClick = (event: React.MouseEvent<unknown>, name: string) => {
    const selectedIndex = selected.indexOf(name);
    let newSelected: readonly string[] = [];

    if (selectedIndex === -1) {
      newSelected = newSelected.concat(selected, name);
    } else if (selectedIndex === 0) {
      newSelected = newSelected.concat(selected.slice(1));
    } else if (selectedIndex === selected.length - 1) {
      newSelected = newSelected.concat(selected.slice(0, -1));
    } else if (selectedIndex > 0) {
      newSelected = newSelected.concat(
        selected?.slice(0, selectedIndex),
        selected?.slice(selectedIndex + 1)
      );
    }
    setSelected && setSelected(newSelected);
  };

  const isSelected = (name: string) => selected.includes(name);

  // Enhanced load more handler with proper debouncing
  const handleLoadMoreData = React.useCallback(() => {
    // Prevent multiple simultaneous loads
    if (isLoadingRef.current || isLoadingMore) {
      console.log('Load blocked: already loading');
      return;
    }

    const now = Date.now();
    // Throttle requests to once per second
    if (now - lastLoadTimeRef.current < 1000) {
      console.log('Load blocked: throttled');
      return;
    }

    const canShowMore = visibleCount < rows.length;
    const canFetchMore = rows.length < totalLength && hasMore && onLoadMore;

    if (!canShowMore && !canFetchMore) {
      console.log('Load blocked: no more data');
      return;
    }

    console.log('Loading more:', { canShowMore, canFetchMore, visibleCount, rowsLength: rows.length });

    if (canShowMore) {
      // Show more existing data
      isLoadingRef.current = true;
      setIsLocalLoading(true);
      lastLoadTimeRef.current = now;

      setTimeout(() => {
        if (isMountedRef.current) {
          setVisibleCount(prev => {
            const newCount = Math.min(prev + 10, rows.length);
            
            // Only trigger server fetch when ALL loaded data is shown
            if (newCount >= rows.length && rows.length < totalLength && hasMore && onLoadMore) {
              console.log('All data shown, triggering server fetch');
              setTimeout(() => {
                if (isMountedRef.current && !isLoadingMore) {
                  onLoadMore();
                }
              }, 100);
            }
            
            return newCount;
          });
          
          setIsLocalLoading(false);
          isLoadingRef.current = false;
        }
      }, 200);
    } else if (canFetchMore) {
      // Trigger server fetch
      console.log('Triggering server fetch');
      isLoadingRef.current = true;
      lastLoadTimeRef.current = now;
      onLoadMore();
      
      // Reset loading flag after delay
      setTimeout(() => {
        if (isMountedRef.current) {
          isLoadingRef.current = false;
        }
      }, 1000);
    }
  }, [visibleCount, rows.length, totalLength, hasMore, onLoadMore, isLoadingMore]);

  // Enhanced intersection observer with proper cleanup
  React.useEffect(() => {
    // Clean up existing observer
    if (observerRef.current) {
      observerRef.current.disconnect();
      observerRef.current = null;
    }

    if (typeof window === "undefined" || !("IntersectionObserver" in window)) {
      return;
    }

    if (!loaderRef.current || !onLoadMore) {
      return;
    }

    const observer = new IntersectionObserver(
      (entries) => {
        const target = entries[0];
        if (target.isIntersecting && isMountedRef.current) {
          handleLoadMoreData();
        }
      },
      { 
        threshold: 0.1,
        rootMargin: '100px'
      }
    );

    observerRef.current = observer;
    observer.observe(loaderRef.current);

    return () => {
      if (observerRef.current) {
        observerRef.current.disconnect();
        observerRef.current = null;
      }
    };
  }, [handleLoadMoreData, onLoadMore]);

  // Reset visible count when filters change (rows reset)
  React.useEffect(() => {
    if (rows.length > 0 && rows.length < visibleCount) {
      console.log('Resetting visible count to match new data');
      setVisibleCount(Math.min(10, rows.length));
      isLoadingRef.current = false;
    }
  }, [rows.length]);

  // Auto-adjust visible count when new data loads
  React.useEffect(() => {
    if (rows.length > visibleCount && !isLoadingMore) {
      // New data was loaded, adjust visible count
      const newVisible = Math.min(visibleCount + 10, rows.length);
      if (newVisible !== visibleCount) {
        console.log('Auto-adjusting visible count:', newVisible);
        setVisibleCount(newVisible);
      }
    }
  }, [rows.length, isLoadingMore]);

  // Handle scroll events
  const handleScroll = React.useCallback((event: React.UIEvent<HTMLDivElement>) => {
    const target = event.currentTarget;
    scrollPositionRef.current = target.scrollTop;
  }, []);

  // Restore scroll after data changes
  React.useEffect(() => {
    if (scrollPositionRef.current > 0 && !loading && !isLoadingMore) {
      restoreScrollPosition();
    }
  }, [rows.length, loading, isLoadingMore, restoreScrollPosition]);

  // Cleanup on unmount
  React.useEffect(() => {
    return () => {
      isMountedRef.current = false;
      if (observerRef.current) {
        observerRef.current.disconnect();
      }
    };
  }, []);

  const visibleRows = React.useMemo(
    () => stableSort(rows, getComparator(order, orderBy)).slice(0, visibleCount),
    [rows, order, orderBy, visibleCount]
  );

  const showLoadingIndicator = isLoadingMore || isLocalLoading;
  const canLoadMore = visibleCount < rows.length || (hasMore && rows.length < totalLength);

  return (
    <Box sx={{ width: "100%", position: 'relative' }}>
      {/* Loading progress bar */}
      {showLoadingIndicator && (
        <Box
          sx={{
            position: 'absolute',
            top: 0,
            left: 0,
            right: 0,
            height: 3,
            zIndex: 1000,
            background: 'linear-gradient(90deg, transparent, #1976d2, transparent)',
            animation: 'slideProgress 1.5s ease-in-out infinite',
            '@keyframes slideProgress': {
              '0%': { transform: 'translateX(-100%)' },
              '100%': { transform: 'translateX(100%)' }
            }
          }}
        />
      )}

      <Paper
        elevation={2}
        sx={{
          borderRadius: ".5rem",
          boxShadow: "none",
          border: "1px solid #ECECEC",
          position: 'relative',
          overflow: 'hidden'
        }}
      >
        <TableContainer 
          ref={tableContainerRef}
          onScroll={handleScroll}
          sx={{ 
            maxHeight: '70vh', 
            overflow: 'auto',
            scrollBehavior: 'auto',
            position: 'relative',
            '&::-webkit-scrollbar': { width: '8px' },
            '&::-webkit-scrollbar-track': { background: '#f1f1f1', borderRadius: '4px' },
            '&::-webkit-scrollbar-thumb': { 
              background: '#c1c1c1', 
              borderRadius: '4px',
              '&:hover': { background: '#a8a8a8' }
            }
          }}
        >
          <Table sx={{ minWidth: 750 }} size="small" stickyHeader>
            <EnhancedTableHead
              order={order}
              orderBy={orderBy}
              onRequestSort={handleRequestSort}
              headCells={headCells}
              serialNo={serialNo}
              expandIconAt={expandIconAt}
              selectable={selectable}
              onSelectAllClick={handleSelectAllClick}
              numSelected={selected?.length}
              rowCount={lengthOfData}
              viewlabel={viewlabel}
              sx={{
                '& .MuiTableCell-head': {
                  backgroundColor: '#ffffff',
                  backdropFilter: 'blur(10px)',
                  borderBottom: '2px solid #e0e0e0',
                  fontWeight: 600,
                  fontSize: '0.875rem',
                  color: 'text.primary',
                  position: 'sticky',
                  top: 0,
                  zIndex: 1100,
                  boxShadow: '0 2px 4px rgba(0,0,0,0.1)',
                }
              }}
            />
            <TableBody>
              {/* Record counter */}
              <TableRow>
                <TableCell 
                  colSpan={headCells.length + (serialNo ? 1 : 0) + (selectable ? 1 : 0)} 
                  sx={{ 
                    backgroundColor: 'rgba(255, 255, 255, 0.95)',
                    backdropFilter: 'blur(8px)',
                    fontWeight: 500,
                    fontSize: '0.875rem',
                    textAlign: 'center',
                    padding: '12px',
                    borderBottom: '2px solid rgba(25, 118, 210, 0.1)',
                    position: 'sticky',
                    top: 56,
                    zIndex: 1000,
                    boxShadow: '0 1px 3px rgba(0,0,0,0.08)',
                  }}
                >
                  <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                    <Typography variant="body2" color="primary.main">
                      Showing {Math.min(visibleCount, rows.length)} of {rows.length} loaded
                    </Typography>
                    <Typography variant="body2" color="text.secondary">
                      {rows.length} / {totalLength || rows.length} total records
                    </Typography>
                  </Box>
                </TableCell>
              </TableRow>

              {/* Table rows */}
              {visibleRows.map((row, index) => {
                const isItemSelected = isSelected(row[uniqueKey]?.toString());
                return expandable ? (
                  <Row
                    key={row[uniqueKey]}
                    expandedRowId={expandedRowId}
                    onToggleExpand={handleToggleExpand}
                    row={row}
                    agentNumber={agentNumber}
                    headCells={headCells}
                    expand={expandable}
                    expandInCols={expandInCols}
                    expandIconAt={expandIconAt}
                    serialNo={serialNo ? index + 1 : undefined}
                    coloumnNumber={coloumnNumber}
                    selectable={
                      selectable && (
                        <TableCell
                          className={styles.stickyLeft}
                          padding="checkbox"
                          sx={{ p: "1rem", left: 0, textAlign: "center" }}
                        >
                          <Checkbox
                            color="primary"
                            checked={isItemSelected}
                            onClick={event =>
                              handleClick(event, row[uniqueKey].toString())
                            }
                          />
                        </TableCell>
                      )
                    }
                  />
                ) : (
                  <TableRow 
                    key={row[uniqueKey]}
                    sx={{
                      '&:hover': {
                        backgroundColor: 'rgba(25, 118, 210, 0.04)',
                        transition: 'background-color 0.2s ease'
                      }
                    }}
                  >
                    {selectable && (
                      <TableCell padding="checkbox" sx={{ p: "1rem" }}>
                        <Checkbox
                          color="primary"
                          checked={isItemSelected}
                          onClick={event =>
                            handleClick(event, row[uniqueKey].toString())
                          }
                        />
                      </TableCell>
                    )}
                    {serialNo && <TableCell>{index + 1}</TableCell>}
                    {headCells.map(headCell => (
                      <TableCell
                        key={headCell.id}
                        className={
                          headCell.stickyClass ? styles[headCell.stickyClass] : ""
                        }
                        sx={{
                          fontSize: "0.875rem",
                          left: headCell.stickyAt,
                          right: headCell.stickyAt,
                        }}
                      >
                        {headCell.cell ? headCell.cell(row) : row[headCell.id]}
                      </TableCell>
                    ))}
                  </TableRow>
                );
              })}

              {/* Loading indicator */}
              {showLoadingIndicator && (
                <TableRow>
                  <TableCell colSpan={headCells.length + (serialNo ? 1 : 0) + (selectable ? 1 : 0)} align="center">
                    <Box sx={{ 
                      p: 3,
                      display: 'flex',
                      flexDirection: 'column',
                      alignItems: 'center',
                      gap: 1.5,
                      background: 'linear-gradient(135deg, rgba(25, 118, 210, 0.05) 0%, rgba(25, 118, 210, 0.02) 100%)',
                      borderRadius: 2,
                      margin: 1,
                    }}>
                      <CircularProgress size={32} thickness={3} />
                      <Typography variant="body2" color="primary.main" sx={{ fontWeight: 500 }}>
                        Loading next 10 records...
                      </Typography>
                    </Box>
                  </TableCell>
                </TableRow>
              )}

              {/* Sentinel for infinite scroll */}
              {canLoadMore && !showLoadingIndicator && (
                <TableRow ref={loaderRef}>
                  <TableCell 
                    colSpan={headCells.length + (serialNo ? 1 : 0) + (selectable ? 1 : 0)}
                    sx={{ height: '40px', background: 'linear-gradient(to bottom, transparent, rgba(25, 118, 210, 0.02), transparent)' }}
                  >
                    <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', opacity: 0.6 }}>
                      <Typography variant="caption" color="text.secondary">
                        {visibleCount < rows.length 
                          ? `Scroll for more... (${visibleCount}/${rows.length} visible)`
                          : `Scroll for more... (${rows.length}/${totalLength} loaded)`
                        }
                      </Typography>
                    </Box>
                  </TableCell>
                </TableRow>
              )}

              {/* All data loaded message */}
              {visibleCount >= rows.length && visibleCount >= totalLength && rows.length >= totalLength && (
                <TableRow>
                  <TableCell colSpan={headCells.length + (serialNo ? 1 : 0) + (selectable ? 1 : 0)} align="center">
                    <Box sx={{ 
                      p: 4,
                      display: 'flex',
                      flexDirection: 'column',
                      alignItems: 'center',
                      gap: 2,
                      background: 'linear-gradient(135deg, rgba(76, 175, 80, 0.05) 0%, rgba(76, 175, 80, 0.02) 100%)',
                      borderRadius: 2,
                      margin: 1,
                    }}>
                      <Box sx={{
                        width: 48,
                        height: 48,
                        borderRadius: '50%',
                        backgroundColor: 'success.main',
                        display: 'flex',
                        alignItems: 'center',
                        justifyContent: 'center',
                      }}>
                        <Typography sx={{ color: 'white', fontSize: '1.5rem' }}>✓</Typography>
                      </Box>
                      <Typography variant="subtitle1" color="success.main" sx={{ fontWeight: 600 }}>
                        All records loaded successfully!
                      </Typography>
                      <Typography variant="body2" color="text.secondary" sx={{ textAlign: 'center' }}>
                        You've viewed all {totalLength} records
                      </Typography>
                    </Box>
                  </TableCell>
                </TableRow>
              )}

              {/* No data */}
              {!loading && lengthOfData <= 0 && (
                <TableRow style={{ height: 53 * 5 }}>
                  <TableCell colSpan={headCells.length} sx={{ textAlign: "center" }}>
                    <NoData image="images/NoData.png" msgHead="No Data Available" />
                  </TableCell>
                </TableRow>
              )}

              {/* Initial loading */}
              {loading && rows.length <= 0 && (
                <TableRow sx={{ height: 53 * 3 }}>
                  <TableCell
                    colSpan={headCells.length + (serialNo ? 1 : 0) + (expandable ? 1 : 0)}
                    sx={{ textAlign: "center" }}
                  >
                    <CircularProgress />
                  </TableCell>
                </TableRow>
              )}

              {/* Total row */}
              {showTotal && (
                <TableRow>
                  <TableCell colSpan={totalColSpan} sx={{ pt: "1rem", pb: "1rem" }}>
                    <Typography>Total</Typography>
                  </TableCell>
                  {headCells.map((headCell, i) => {
                    if (headCell.numeric) {
                      return (
                        <TableCell key={i} sx={{ fontWeight: 700 }}>
                          {getSum(rows, headCell.id)}
                        </TableCell>
                      );
                    }
                    if (i !== 0) return <TableCell key={i} />;
                    return null;
                  })}
                  {expandIconAt === "end" && <TableCell />}
                </TableRow>
              )}
            </TableBody>
          </Table>
        </TableContainer>
      </Paper>
    </Box>
  );
};

ScrollableTable.defaultProps = {
  serialNo: false,
  selectable: false,
  expandIconAt: "start",
  uniqueKey: "id",
  actions: [],
  loading: false,
  deleteButton: false,
  selected: [],
};

export default ScrollableTable;


// Refactored Campaigns Component - Production Ready
import theme from "@/theme";
import {
  Box, Button, Modal, Typography
} from "@mui/material";
import React from "react";
import CampaignsList from "./CampaignsList";
import DispositionFormCA from "./DispositionFormCA";
import { handleApiError } from "@/utils/handleApiError";
import CheckCircleOutlineIcon from "@mui/icons-material/CheckCircleOutline";
import WarningAmberIcon from "@mui/icons-material/WarningAmber";
import ErrorOutlineIcon from "@mui/icons-material/ErrorOutline";
import { useWebSocket } from "@/hooks/useWebSocket";
import PageContainer from "ui/common/containers/PageContainer";
import { 
  getCampaignNumbers, 
  getCampaignsList, 
  hightOrderCaptureResponse, 
  unlockCallCenterOrder 
} from "@/modules";
import { getCookie, setCookie } from "cookies-next";
import AgentModal from "./CallerAgent/AgentModal";

// Interfaces
interface WebSocketMessage {
  type: string;
  data: any;
  timestamp: string;
}

interface DepartmentData {
  id: string;
  patientId: string;
  prescriptionId: string;
  patientName?: string;
  phoneNumber?: string;
  leadStatus?: string;
  department?: string;
  unit?: string;
  agent_number?: string;
  call_status?: string;
  [key: string]: any;
}

interface CallIdentifier {
  patientId: string;
  prescriptionId: string;
  customerNumber: string;
  timestamp: number;
}

// Modal Styles
const modalStyles = {
  display: "flex",
  justifyContent: "center",
  alignItems: "center",
  p: 1,
  zIndex: (theme: any) => theme.zIndex.modal + 10,
};

const modalContainerStyles = {
  bgcolor: "background.paper",
  borderRadius: 1,
  p: 3,
  boxShadow: "0 8px 32px rgba(0, 0, 0, 0.12)",
  border: "1px solid",
  borderColor: "divider",
  textAlign: "center" as const,
  display: "flex",
  flexDirection: "column" as const,
  alignItems: "center",
  gap: 1.5,
  minWidth: "280px",
  maxWidth: "400px",
  width: "90%",
  maxHeight: "90vh",
  overflow: "auto",
};

const iconContainerStyles = {
  width: 48,
  height: 48,
  borderRadius: "50%",
  display: "flex",
  justifyContent: "center",
  alignItems: "center",
  mb: 0.5,
};

const primaryButtonStyles = {
  borderRadius: 1,
  px: 2.5,
  py: 0.75,
  textTransform: "none" as const,
  fontWeight: 500,
  fontSize: "0.875rem",
  minWidth: "100px",
  height: "36px",
};

const secondaryButtonStyles = {
  borderRadius: 1,
  px: 2.5,
  py: 0.75,
  textTransform: "none" as const,
  fontWeight: 500,
  fontSize: "0.875rem",
  minWidth: "100px",
  height: "36px",
};

const Campaigns = (props: any) => {
  const { filters, tab } = props;

  // State Management
  const [tableData, setTableData] = React.useState<DepartmentData[]>([]);
  const [isLoading, setIsLoading] = React.useState<boolean>(false);
  const [totalRecords, setTotalRecords] = React.useState<number>(0);
  const [pageNumberClicked, setPageNumberClicked] = React.useState<number>(1);
  const [pageSize, setPageSize] = React.useState<number>(10);
  const [closeLeadModal, setCloseLeadModal] = React.useState(false);
  const [rowDataCL, setRowDataCL] = React.useState<DepartmentData | null>(null);
  const [captureResponseModal, setCaptureResponseModal] = React.useState(false);
  const [rowDataCR, setRowDataCR] = React.useState<DepartmentData | null>(null);
  const [successMsgModal, setSuccessMsgModal] = React.useState(false);
  const [itemSelected, setItemSelected] = React.useState<string[]>([]);
  const [agentNumber, setAgentNumber] = React.useState<string>('');
  const [agentModal, setAgentModal] = React.useState<boolean>(false);
  const [modalType, setModalType] = React.useState<"capture" | "close" | "dnd" | null>(null);
  const [campaignNumbers, setCampaignNumbers] = React.useState<any>([]);
  const [isLoadingMore, setIsLoadingMore] = React.useState(false);

  // Refs for managing async operations
  const isMountedRef = React.useRef(true);
  const activeRequestRef = React.useRef<AbortController | null>(null);
  const processedCallsRef = React.useRef<Map<string, CallIdentifier>>(new Map());
  const autoCloseTimeoutRef = React.useRef<Map<string, NodeJS.Timeout>>(new Map());
  const customerNumberRef = React.useRef<string | null>(null);
  const debounceTimeoutRef = React.useRef<NodeJS.Timeout | null>(null);
  const wsUnsubscribeRef = React.useRef<(() => void) | null>(null);
  
  // Scroll handlers
  const scrollHandlersRef = React.useRef<{
    saveScrollPosition: () => void;
    restoreScrollPosition: () => void;
  } | null>(null);

  // Check if any modal is open
  const isAnyModalOpen = React.useCallback(() => {
    return captureResponseModal || closeLeadModal || successMsgModal || agentModal;
  }, [captureResponseModal, closeLeadModal, successMsgModal, agentModal]);

  // Enhanced data fetching with abort controller
  const getHighOrderValueData = React.useCallback(async (preserveScroll = false) => {
    // Skip if modal is open
    if (isAnyModalOpen()) {
      console.log("Skipping data refresh - modal is open");
      return;
    }

    // Cancel previous request
    if (activeRequestRef.current) {
      activeRequestRef.current.abort();
    }

    // Create new abort controller
    const abortController = new AbortController();
    activeRequestRef.current = abortController;

    // Save scroll position if needed
    if (preserveScroll && scrollHandlersRef.current) {
      scrollHandlersRef.current.saveScrollPosition();
    }

    setIsLoading(true);

    try {
      const response = await getCampaignsList({
        leadStatus: filters.leadStatus || 'ALL',
        page: pageNumberClicked,
        limit: pageSize,
        searchString: filters.searchString || '',
        unit: filters.unit,
        department: filters.dept,
        category: 'ALL',
        source: 'ALL'
      });

      // Check if component is still mounted and request wasn't aborted
      if (!isMountedRef.current || abortController.signal.aborted) {
        return;
      }

      if (response.success) {
        setTableData(response.data?.data || []);
        setTotalRecords(response.data?.totalRecords || 0);
        
        // Restore scroll position after state update
        if (preserveScroll && scrollHandlersRef.current) {
          setTimeout(() => {
            scrollHandlersRef.current?.restoreScrollPosition();
          }, 100);
        }
      } else {
        console.error("API Error:", response.message);
        handleApiError(response.message);
      }
    } catch (error: any) {
      if (error.name === 'AbortError') {
        console.log('Request was aborted');
        return;
      }
      if (isMountedRef.current) {
        console.error("Unexpected Error:", error);
        handleApiError("Something went wrong while fetching data.");
      }
    } finally {
      if (isMountedRef.current) {
        setIsLoading(false);
        activeRequestRef.current = null;
      }
    }
  }, [filters, pageNumberClicked, pageSize, isAnyModalOpen]);

  // Fetch campaign numbers
  const getCampaignNumbersData = React.useCallback(async () => {
    if (isAnyModalOpen()) {
      console.log("Skipping campaign numbers fetch - modal is open");
      return;
    }

    try {
      const response = await getCampaignNumbers();

      if (!isMountedRef.current) return;

      if (response.success) {
        setCampaignNumbers(response.data?.numbers || []);
      } else {
        console.error("API Error:", response.message);
        handleApiError(response.message);
      }
    } catch (error) {
      if (isMountedRef.current) {
        console.error("Unexpected Error:", error);
        handleApiError("Something went wrong while fetching campaign numbers.");
      }
    }
  }, [isAnyModalOpen]);

  // Auto-close lead with deduplication
  const handleAutomaticallyCloseLead = React.useCallback(async (
    patientId: string, 
    prescriptionId: string, 
    customerNumber: string
  ) => {
    if (!patientId || !prescriptionId || !customerNumber) {
      console.warn("Missing required parameters for auto-close");
      return;
    }

    const callKey = `${patientId}_${prescriptionId}_${customerNumber}`;
    const now = Date.now();
    
    // Check if we've processed this call recently (within 30 seconds)
    const existingCall = processedCallsRef.current.get(callKey);
    if (existingCall && (now - existingCall.timestamp) < 30000) {
      console.log("Call already processed recently, skipping:", callKey);
      return;
    }

    // Mark as processed
    processedCallsRef.current.set(callKey, {
      patientId,
      prescriptionId,
      customerNumber,
      timestamp: now
    });

    // Clean up old entries (older than 60 seconds)
    for (const [key, value] of processedCallsRef.current.entries()) {
      if (now - value.timestamp > 60000) {
        processedCallsRef.current.delete(key);
      }
    }

    try {
      const res = await hightOrderCaptureResponse({
        comments: "Ringing No Answer and system automatically closed lead",
        patientId,
        prescriptionId,
        followUpStatus: "No",
        callDisposition: "Non-contact",
        serviceDispositionL1: "Ringing no Response",
        serviceDispositionL2: "",
        dnd: false,
        mobileNo: customerNumber,
      });

      if (isMountedRef.current && (res.success || res?.statusCode === 201)) {
        console.log("Lead auto-closed successfully");
        await getHighOrderValueData(true);
      }
    } catch (error) {
      console.error("Error in handleAutomaticallyCloseLead:", error);
      if (isMountedRef.current) {
        handleApiError(error);
      }
    }
  }, [getHighOrderValueData]);

  // Handle knowlarity events with proper debouncing
  const handleKnowlarityEvent = React.useCallback((eventData: any) => {
    if (!eventData || !eventData.event_type) {
      console.warn('Invalid knowlarity event received');
      return;
    }

    console.log('Knowlarity event:', eventData.event_type);

    try {
      // Handle different event types
      if (eventData?.event_type === "CUSTOMER_CALL") {
        customerNumberRef.current = eventData?.customer_number;
      }

      if (eventData?.event_type === "CUSTOMER_ANSWER" || eventData?.event_type === "BRIDGE") {
        if (customerNumberRef.current === eventData?.customer_number) {
          customerNumberRef.current = null;
        }
      }

      if (eventData?.event_type === "HANGUP") {
        const patientId = eventData?.department?.patientId;
        const prescriptionId = eventData?.department?.prescriptionId;
        const customerNumber = eventData?.customer_number;
        const callIdentifier = `${patientId}_${prescriptionId}_${customerNumber}`;

        if (customerNumberRef.current === customerNumber && patientId && prescriptionId) {
          // Clear existing timeout
          const existingTimeout = autoCloseTimeoutRef.current.get(callIdentifier);
          if (existingTimeout) {
            clearTimeout(existingTimeout);
          }

          // Set new timeout with proper cleanup
          const timeout = setTimeout(() => {
            handleAutomaticallyCloseLead(patientId, prescriptionId, customerNumber);
            autoCloseTimeoutRef.current.delete(callIdentifier);
          }, 2000);

          autoCloseTimeoutRef.current.set(callIdentifier, timeout);
          customerNumberRef.current = null;
        }
      }

      // Skip data refresh if modal is open
      if (isAnyModalOpen()) {
        console.log("Skipping data refresh - modal is open");
        return;
      }

      // Debounced data refresh
      if (debounceTimeoutRef.current) {
        clearTimeout(debounceTimeoutRef.current);
      }

      debounceTimeoutRef.current = setTimeout(() => {
        if (!isAnyModalOpen() && isMountedRef.current) {
          getHighOrderValueData(true);
          setTimeout(() => {
            if (isMountedRef.current) {
              getCampaignNumbersData();
            }
          }, 2000);
        }
      }, 500);
    } catch (error) {
      console.error('Error handling knowlarity event:', error);
    }
  }, [isAnyModalOpen, getHighOrderValueData, getCampaignNumbersData, handleAutomaticallyCloseLead]);

  // Modal handlers
  const handleCloseLead = React.useCallback((value: any) => {
    if (debounceTimeoutRef.current) {
      clearTimeout(debounceTimeoutRef.current);
      debounceTimeoutRef.current = null;
    }
    setCloseLeadModal(true);
    setRowDataCL(value);
  }, []);

  const handleConfirmCloseLead = React.useCallback(async (rowDataCL: any) => {
    try {
      const res = await hightOrderCaptureResponse({
        patientId: rowDataCL?.patientId,
        prescriptionId: rowDataCL?.prescriptionId,
        followUpStatus: "No"
      });

      if (isMountedRef.current && res?.statusCode === 201) {
        await unlockCallCenterOrder({
          patientId: rowDataCL?.patientId,
          prescriptionId: rowDataCL?.prescriptionId,
          name: tab,
        });
        await getHighOrderValueData();
        setModalType("close");
        setSuccessMsgModal(true);
      }
    } catch (error) {
      if (isMountedRef.current) {
        handleApiError(error);
      }
    } finally {
      if (isMountedRef.current) {
        setCloseLeadModal(false);
      }
    }
  }, [tab, getHighOrderValueData]);

  const handleCaptureResponse = React.useCallback((value: any) => {
    if (debounceTimeoutRef.current) {
      clearTimeout(debounceTimeoutRef.current);
      debounceTimeoutRef.current = null;
    }
    setCaptureResponseModal(true);
    setRowDataCR(value);
  }, []);

  const handleSubmitCaptureResponse = React.useCallback(async (
    updatedReason: any,
    valueFollowups: any,
    followUpDate: any,
    valueTime: any,
    selectedCD: any,
    selectedL1: any,
    selectedL2: any,
    additionalComment: string,
    dnd: boolean,
    mobileNo: string
  ) => {
    try {
      const res = await hightOrderCaptureResponse({
        comments: additionalComment,
        patientId: rowDataCR?.patientId,
        prescriptionId: rowDataCR?.prescriptionId,
        orderId: rowDataCR?.orderId,
        followUpStatus: valueFollowups,
        ...(followUpDate && { followUpDate }),
        callDisposition: selectedCD,
        serviceDispositionL1: selectedL1,
        serviceDispositionL2: selectedL2,
        timings: valueTime?.format("hh:mm A"),
        dnd,
        mobileNo,
      });

      if (isMountedRef.current && (res.success || res?.statusCode === 201)) {
        await getHighOrderValueData();
        setCaptureResponseModal(false);
        setModalType(dnd ? "dnd" : "capture");
        setSuccessMsgModal(true);
      }
    } catch (error) {
      if (isMountedRef.current) {
        handleApiError(error);
      }
    }
  }, [rowDataCR, getHighOrderValueData]);

  const closingCaptureResponseModal = React.useCallback(async (row: any) => {
    try {
      await unlockCallCenterOrder({
        patientId: row?.patientId,
        prescriptionId: row?.prescriptionId,
        name: tab,
      });
      await getHighOrderValueData();
    } catch (error) {
      console.error("Error closing capture response modal:", error);
      if (isMountedRef.current) {
        handleApiError("Failed to unlock order");
      }
    } finally {
      if (isMountedRef.current) {
        setCaptureResponseModal(false);
      }
    }
  }, [tab, getHighOrderValueData]);

  const closingCloseLeadModal = React.useCallback(async () => {
    try {
      await unlockCallCenterOrder({
        patientId: rowDataCL?.patientId,
        prescriptionId: rowDataCL?.prescriptionId,
        name: tab,
      });
      await getHighOrderValueData();
    } catch (error) {
      console.error("Error closing lead modal:", error);
      if (isMountedRef.current) {
        handleApiError("Failed to unlock order");
      }
    } finally {
      if (isMountedRef.current) {
        setCloseLeadModal(false);
      }
    }
  }, [rowDataCL, tab, getHighOrderValueData]);

  const handleAgentNumber = React.useCallback(() => {
    setCookie("agent_number", agentNumber);
    setAgentModal(false);
  }, [agentNumber]);

  // Load more handler with proper deduplication
  const handleLoadMore = React.useCallback(async () => {
    if (isLoadingMore || tableData.length >= totalRecords || isAnyModalOpen()) {
      return;
    }

    setIsLoadingMore(true);

    try {
      const nextPage = Math.floor(tableData.length / 10) + 1;

      const response = await getCampaignsList({
        leadStatus: filters.leadStatus || 'ALL',
        page: nextPage,
        limit: 10,
        searchString: filters.searchString || '',
        unit: filters.unit || 'ALL',
        department: filters.dept || 'ALL',
        category: 'ALL',
        source: filters.source || 'ALL'
      });

      if (!isMountedRef.current) return;

      if (response.success && response.data?.data) {
        const newRecords = response.data.data;
        
        setTableData(prev => {
          const existingIds = new Set(
            prev.map(item => `${item.patientId}_${item.prescriptionId}`)
          );
          const uniqueNewRecords = newRecords.filter(
            (record: any) => !existingIds.has(`${record.patientId}_${record.prescriptionId}`)
          );
          return [...prev, ...uniqueNewRecords];
        });

        if (response.data.totalRecords !== totalRecords) {
          setTotalRecords(response.data.totalRecords);
        }
      }
    } catch (error) {
      console.error("Error loading more data:", error);
      if (isMountedRef.current) {
        handleApiError("Failed to load more data");
      }
    } finally {
      if (isMountedRef.current) {
        setTimeout(() => setIsLoadingMore(false), 300);
      }
    }
  }, [isLoadingMore, tableData.length, totalRecords, filters, isAnyModalOpen]);

  const handleScrollHandlersReady = React.useCallback((handlers: any) => {
    scrollHandlersRef.current = handlers;
  }, []);

  // WebSocket setup with proper cleanup
  const { isConnected, on } = useWebSocket({
    onConnect: () => console.log('Connected to CallerAgent WebSocket'),
    onDisconnect: () => console.log('Disconnected from CallerAgent WebSocket'),
    onError: (error) => console.error('WebSocket error:', error),
  });

  // Setup WebSocket listeners
  React.useEffect(() => {
    const unsubscribe = on('knowlarityEvent', (message: WebSocketMessage) => {
      handleKnowlarityEvent(message.data.event || message.data);
    });

    wsUnsubscribeRef.current = unsubscribe;

    return () => {
      if (wsUnsubscribeRef.current) {
        wsUnsubscribeRef.current();
      }
    };
  }, [on, handleKnowlarityEvent]);

  // Reset page on filter changes
  React.useEffect(() => {
    setPageNumberClicked(1);
    setItemSelected([]);
  }, [filters.leadStatus, filters.dept, filters.searchString, filters.date, filters.unit]);

  // Fetch data on mount and filter/page changes
  React.useEffect(() => {
    getHighOrderValueData(false);
    getCampaignNumbersData();
  }, [filters, pageNumberClicked, pageSize]);

  // Check agent number on mount
  React.useEffect(() => {
    const _agentNumber = getCookie("agent_number");
    if (_agentNumber) {
      setAgentNumber(_agentNumber as string);
    } else {
      setAgentModal(true);
    }
  }, []);

  // Cleanup on unmount
  React.useEffect(() => {
    return () => {
      isMountedRef.current = false;

      // Abort active requests
      if (activeRequestRef.current) {
        activeRequestRef.current.abort();
      }

      // Clear all timeouts
      if (debounceTimeoutRef.current) {
        clearTimeout(debounceTimeoutRef.current);
      }

      autoCloseTimeoutRef.current.forEach(timeout => clearTimeout(timeout));
      autoCloseTimeoutRef.current.clear();

      // Clear processed calls
      processedCallsRef.current.clear();

      // Unsubscribe from WebSocket
      if (wsUnsubscribeRef.current) {
        wsUnsubscribeRef.current();
      }
    };
  }, []);

  const tableDataWithKey = tableData.map((row: any) => ({
    ...row,
    patientPrescriptionKey: `${row.patientId}_${row.prescriptionId}`,
  }));

  return (
    <>
      <AgentModal 
        agentModal={agentModal} 
        setAgentModal={setAgentModal} 
        setAgentNumber={setAgentNumber} 
        handleAgentNumber={handleAgentNumber} 
      />

      <Box sx={{ bgcolor: theme.palette.primary.light, display: "flex", height: "100%" }}>
        <PageContainer>
          <Box sx={{ display: "flex", alignItems: "flex-start", justifyContent: "flex-start" }}>
            <CampaignsList
              selected={itemSelected}
              setItemSelected={setItemSelected}
              tableData={tableDataWithKey}
              isLoading={isLoading}
              agentNumber={agentNumber}
              campaignNumbers={campaignNumbers}
              pageNumberClicked={pageNumberClicked}
              setPageNumberClicked={setPageNumberClicked}
              recordsToShow={pageSize}
              setRecordsToShow={setPageSize}
              totalRecords={totalRecords}
              setTotalRecords={setTotalRecords}
              getConversionPendingData={''}
              handleCloseLead={handleCloseLead}
              handleCaptureResponse={handleCaptureResponse}
              tab={tab}
              onLoadMore={handleLoadMore}
              onScrollHandlersReady={handleScrollHandlersReady}
              isLoadingMore={isLoadingMore}
            />

            {/* Close Lead Modal */}
            <Modal open={closeLeadModal} onClose={closingCloseLeadModal} sx={modalStyles}>
              <Box sx={modalContainerStyles}>
                <Box sx={{
                  ...iconContainerStyles,
                  backgroundColor: "rgba(255, 152, 0, 0.1)",
                  border: "2px solid",
                  borderColor: "warning.main"
                }}>
                  <ErrorOutlineIcon sx={{ color: "warning.main", fontSize: "1.5rem" }} />
                </Box>

                <Typography variant="subtitle1" fontWeight={600} color="text.primary" sx={{ mb: 1 }}>
                  Confirm Lead Closure
                </Typography>

                <Typography variant="body2" color="text.secondary" sx={{ mb: 2, lineHeight: 1.4 }}>
                  Are you sure you want to close this lead? This action cannot be undone.
                </Typography>

                <Box display="flex" justifyContent="center" gap={1.5} sx={{ width: "100%" }}>
                  <Button
                    onClick={closingCloseLeadModal}
                    variant="outlined"
                    sx={{
                      ...secondaryButtonStyles,
                      borderColor: "grey.400",
                      color: "text.secondary",
                      '&:hover': { borderColor: "grey.600", backgroundColor: "grey.50" }
                    }}
                  >
                    Cancel
                  </Button>
                  <Button
                    onClick={() => handleConfirmCloseLead(rowDataCL)}
                    variant="contained"
                    sx={{
                      ...primaryButtonStyles,
                      backgroundColor: "warning.main",
                      '&:hover': { backgroundColor: "warning.dark" }
                    }}
                  >
                    Close Lead
                  </Button>
                </Box>
              </Box>
            </Modal>

            {/* Success/DND Modal */}
            <Modal open={successMsgModal} onClose={() => setSuccessMsgModal(false)} sx={modalStyles}>
              <Box sx={modalContainerStyles}>
                <Box sx={{
                  ...iconContainerStyles,
                  backgroundColor: modalType === "dnd" ? "rgba(244, 67, 54, 0.1)" : "rgba(76, 175, 80, 0.1)",
                  border: "2px solid",
                  borderColor: modalType === "dnd" ? "error.main" : "success.main",
                }}>
                  {modalType === "dnd" ? (
                    <WarningAmberIcon sx={{ color: "error.main", fontSize: "1.5rem" }} />
                  ) : (
                    <CheckCircleOutlineIcon sx={{ color: "success.main", fontSize: "1.5rem" }} />
                  )}
                </Box>

                {modalType === "close" && (
                  <>
                    <Typography variant="subtitle1" fontWeight={600} color="success.main" sx={{ mb: 1 }}>
                      Lead Closed Successfully!
                    </Typography>
                    <Typography variant="body2" color="text.secondary" sx={{ lineHeight: 1.4 }}>
                      The lead has been closed and saved in the system.
                    </Typography>
                  </>
                )}

                {modalType === "capture" && (
                  <>
                    <Typography variant="h6" fontWeight="bold" color="success.main">
                      Response Captured Successfully!
                    </Typography>
                    <Typography variant="body2" color="text.secondary">
                      The patient's response has been recorded.
                    </Typography>
                  </>
                )}

                {modalType === "dnd" && (
                  <>
                    <Typography variant="subtitle1" fontWeight={600} color="error.main" sx={{ mb: 1 }}>
                      DND Enabled!
                    </Typography>
                    <Typography variant="body2" color="text.secondary" sx={{ lineHeight: 1.4 }}>
                      DND has been enabled for patient {rowDataCR?.patientId}.
                    </Typography>
                  </>
                )}

                <Button
                  onClick={() => setSuccessMsgModal(false)}
                  variant="contained"
                  sx={{
                    ...primaryButtonStyles,
                    mt: 1.5,
                    backgroundColor: modalType === "dnd" ? "error.main" : "success.main",
                    '&:hover': { backgroundColor: modalType === "dnd" ? "error.dark" : "success.dark" }
                  }}
                >
                  OK
                </Button>
              </Box>
            </Modal>

            {/* Capture Response Modal */}
            <DispositionFormCA
              open={captureResponseModal}
              onClose={() => closingCaptureResponseModal(rowDataCR)}
              handleSubmitCapture={handleSubmitCaptureResponse}
              rowData={rowDataCR}
            />
          </Box>
        </PageContainer>
      </Box>
    </>
  );
};

export default Campaigns;
