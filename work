//High order value component
import theme from "@/theme";
import {
	Box, Button, Modal, Typography
} from "@mui/material";
import React from "react";
import HighValueOrderList from "./HighValueOrderList";
import DispositionFormCA from "./DispositionFormCA";
import { handleApiError } from "@/utils/handleApiError";
import CheckCircleOutlineIcon from "@mui/icons-material/CheckCircleOutline";
import WarningAmberIcon from "@mui/icons-material/WarningAmber";
import ErrorOutlineIcon from "@mui/icons-material/ErrorOutline";
import { useWebSocket } from "@/hooks/useWebSocket";
import PageContainer from "ui/common/containers/PageContainer";
import { getCampaignNumbers, getCampaignsList, getHighOrderValue, hightOrderCaptureResponse, unlockCallCenterOrder } from "@/modules";
import { getCookie, setCookie } from "cookies-next";
import AgentModal from "./CallerAgent/AgentModal";
import { Campaign } from "@mui/icons-material";
import CampaignsList from "./CampaignsList";

// WebSocket message interface
interface WebSocketMessage {
	type: string;
	data: any;
	timestamp: string;
}

// Professional modal styles optimized for small screens
const modalStyles = {
	display: "flex",
	justifyContent: "center",
	alignItems: "center",
	p: 1, // Add padding for small screens
	zIndex: (theme: any) => theme.zIndex.modal + 10,
};

const modalContainerStyles = {
	bgcolor: "background.paper",
	borderRadius: 1,
	p: 3,
	boxShadow: "0 8px 32px rgba(0, 0, 0, 0.12)",
	border: "1px solid",
	borderColor: "divider",
	textAlign: "center" as const,
	display: "flex",
	flexDirection: "column" as const,
	alignItems: "center",
	gap: 1.5,
	minWidth: "280px",
	maxWidth: "400px",
	width: "90%",
	maxHeight: "90vh",
	overflow: "auto",
};

const iconContainerStyles = {
	width: 48,
	height: 48,
	borderRadius: "50%",
	display: "flex",
	justifyContent: "center",
	alignItems: "center",
	mb: 0.5,
};

const primaryButtonStyles = {
	borderRadius: 1,
	px: 2.5,
	py: 0.75,
	textTransform: "none" as const,
	fontWeight: 500,
	fontSize: "0.875rem",
	minWidth: "100px",
	height: "36px",
};

const secondaryButtonStyles = {
	borderRadius: 1,
	px: 2.5,
	py: 0.75,
	textTransform: "none" as const,
	fontWeight: 500,
	fontSize: "0.875rem",
	minWidth: "100px",
	height: "36px",
};

const Campaigns = (props: any) => {
	const { filters, tab } = props;
	// Define department interface
	interface DepartmentData {
		id: string;
		patientId: string;
		prescriptionId: string;
		patientName?: string;
		phoneNumber?: string;
		leadStatus?: string;
		department?: string;
		unit?: string;
		agent_number?: string;
		call_status?: string;
		[key: string]: any; // Allow additional properties
	}

	const [tableData, setTableData] = React.useState<DepartmentData[]>([]);
	const [isLoading, setIsLoading] = React.useState<boolean>(false);
	const [totalRecords, setTotalRecords] = React.useState<number>(0);
	const [pageNumberClicked, setPageNumberClicked] = React.useState<number>(1);
	const [pageSize, setPageSize] = React.useState<number>(10); // Keep as 10
	const [closeLeadModal, setCloseLeadModal] = React.useState(false)
	const [rowDataCL, setRowDataCL] = React.useState<DepartmentData | null>(null)
	const [captureResponseModal, setCaptureResponseModal] = React.useState(false)
	const [rowDataCR, setRowDataCR] = React.useState<DepartmentData | null>(null)
	const [successMsgModal, setSuccessMsgModal] = React.useState(false)
	const [itemSelected, setItemSelected] = React.useState<string[]>([]);
	const [agentNumber, setAgentNumber] = React.useState<string>('');
	const [agentModal, setAgentModal] = React.useState<boolean>(false);
	const [modalType, setModalType] = React.useState<"capture" | "close" | "dnd" | null>(null);
	const [campaignNumbers, setCampaignNumbers] = React.useState<any>([]);
	const [isLoadingMore, setIsLoadingMore] = React.useState(false);
	const [loadingProgress, setLoadingProgress] = React.useState(0);

	const debounceTimeoutRef = React.useRef<NodeJS.Timeout | null>(null);

	// Add refs to track processed calls and prevent duplicates
	const processedCallsRef = React.useRef<Set<string>>(new Set());
	const autoCloseTimeoutRef = React.useRef<Map<string, NodeJS.Timeout>>(new Map());
	const customerNumberRef = React.useRef<string | null>(null);

	// Create refs to always access latest values
	const filtersRef = React.useRef(filters);
	const pageNumberClickedRef = React.useRef(pageNumberClicked);
	const pageSizeRef = React.useRef(pageSize);

	// Update refs when values change
	React.useEffect(() => {
		filtersRef.current = filters;
	}, [filters]);

	React.useEffect(() => {
		pageNumberClickedRef.current = pageNumberClicked;
	}, [pageNumberClicked]);

	React.useEffect(() => {
		pageSizeRef.current = pageSize;
	}, [pageSize]);

	// before returning JSX
	const tableDataWithKey = tableData.map((row: any) => ({
		...row,
		patientPrescriptionKey: `${row.patientId}_${row.prescriptionId}`,
	}));

	// Initialize WebSocket connection
	const { isConnected, on } = useWebSocket({
		onConnect: () => console.log('Connected to CallerAgent WebSocket'),
		onDisconnect: () => console.log('Disconnected from CallerAgent WebSocket'),
		onError: (error) => console.error('WebSocket error:', error),
	});

	// Add refs to track modal states in real-time
	const modalStatesRef = React.useRef({
		captureResponseModal: false,
		closeLeadModal: false,
		successMsgModal: false,
		agentModal: false
	});

	// Update refs whenever modal states change
	React.useEffect(() => {
		modalStatesRef.current = {
			captureResponseModal,
			closeLeadModal,
			successMsgModal,
			agentModal
		};
	}, [captureResponseModal, closeLeadModal, successMsgModal, agentModal]);

	// ðŸ”¥ Add scroll handlers ref
	const scrollHandlersRef = React.useRef<{
		saveScrollPosition: () => void;
		restoreScrollPosition: () => void;
	} | null>(null);

	const handleScrollHandlersReady = React.useCallback((handlers: any) => {
		scrollHandlersRef.current = handlers;
	}, []);

	const getHighOrderValueData = React.useCallback(async (preserveScroll = false) => {
		// ADD: Check modal state before any data operations
		if (captureResponseModal || closeLeadModal || successMsgModal || agentModal) {
			console.log("Skipping data refresh due to cron job - modal is open:", {
				captureResponseModal,
				closeLeadModal,
				successMsgModal,
				agentModal
			});
			return;
		}

		const isAnyModalOpen = () => {
			const states = modalStatesRef.current;
			return states.captureResponseModal || states.closeLeadModal ||
				states.successMsgModal || states.agentModal;
		};

		if (isAnyModalOpen()) {
			console.log("Skipping data refresh in highvalueapi - modal is open:", modalStatesRef.current);
			return;
		}

		// ðŸ”¥ Save scroll position before data refresh (for cron jobs/websocket events)
		if (preserveScroll && scrollHandlersRef.current) {
			console.log("ðŸ’¾ Saving scroll position before data refresh");
			scrollHandlersRef.current.saveScrollPosition();
		}

		setIsLoading(true);

		try {
			const currentFilters = filtersRef.current;
			const currentPage = pageNumberClickedRef.current;
			const currentPageSize = pageSizeRef.current;

			// const response = await getHighOrderValue({
			// 	leadStatus: currentFilters.leadStatus,
			// 	page: currentPage,
			// 	limit: currentPageSize,
			// 	department: currentFilters.dept,
			// 	searchString: currentFilters.searchString,
			// 	date: currentFilters.date,
			// 	unit: currentFilters.unit,
			// 	campaign: currentFilters.campaign,
			// 	call_status: currentFilters.call_status
			// });
			const response = await getCampaignsList({
				leadStatus: currentFilters.leadStatus || 'ALL',
				page: currentPage,
				limit: currentPageSize,
				searchString: currentFilters.searchString || '',
				unit: currentFilters.unit,
				department: currentFilters.dept,
				category: 'ALL',
				source: 'ALL'
			});

			if (response.success) {
				setTableData(response.data?.data || []);
				setTotalRecords(response.data?.totalRecords || 0);
			} else {
				console.error("API Error:", response.message);
				handleApiError(response.message);
			}
		} catch (error) {
			console.error("Unexpected Error:", error);
			handleApiError("Something went wrong while fetching data.");
		} finally {
			setIsLoading(false);
		}
	}, [captureResponseModal, closeLeadModal, successMsgModal, agentModal]);

	// Fetch campaign numbers
	const getCampaignNumbersData = React.useCallback(async () => {
		const isAnyModalOpen = () => {
			const states = modalStatesRef.current;
			return states.captureResponseModal || states.closeLeadModal ||
				states.successMsgModal || states.agentModal;
		};

		if (isAnyModalOpen()) {
			console.log("Skipping data refresh in campaignapi - modal is open:", modalStatesRef.current);
			return;
		}
		try {
			const response = await getCampaignNumbers();

			if (response.success) {
				setCampaignNumbers(response.data?.numbers || []);
			} else {
				console.error("API Error:", response.message);
				handleApiError(response.message);
			}
		} catch (error) {
			console.error("Unexpected Error:", error);
			handleApiError("Something went wrong while fetching campaign numbers.");
		}
	}, []);

	// Handle knowlarity events with debouncing and duplicate prevention
	const handleKnowlarityEvent = React.useCallback((eventData: any) => {
		// Add event validation
		if (!eventData || !eventData.event_type) {
			console.warn('Invalid knowlarity event received:', eventData);
			return;
		}

		// Log every event for debugging
		console.log('Knowlarity event received:', {
			type: eventData.event_type,
			timestamp: new Date().toISOString(),
			data: eventData
		});

		try {
			const isAnyModalOpen = () => {
				const states = modalStatesRef.current;
				return states.captureResponseModal || states.closeLeadModal ||
					states.successMsgModal || states.agentModal;
			};

			if (eventData?.event_type === "CUSTOMER_CALL") {
				console.log("Customer call event detected:", customerNumberRef.current);
				customerNumberRef.current = eventData?.customer_number;
			}

			if (eventData?.event_type === "CUSTOMER_ANSWER" || eventData?.event_type === "BRIDGE") {
				console.log("Call answered or bridged event detected:", customerNumberRef.current, eventData?.customer_number);
				if (customerNumberRef.current === eventData?.customer_number) {
					customerNumberRef.current = null;
				}
			}

			if (eventData?.event_type === "HANGUP") {
				console.log("Call hangup event detected:", customerNumberRef.current, eventData?.customer_number);

				const patientId = eventData?.department?.patientId;
				const prescriptionId = eventData?.department?.prescriptionId;
				const customerNumber = eventData?.customer_number;

				// Create unique identifier for this call
				const callIdentifier = `${patientId}_${prescriptionId}_${customerNumber}`;

				// Only process if this is the customer we're tracking and we haven't processed this call already
				if (customerNumberRef.current === customerNumber &&
					patientId &&
					prescriptionId &&
					!processedCallsRef.current.has(callIdentifier)) {

					// Mark this call as processed immediately
					processedCallsRef.current.add(callIdentifier);

					// Clear any existing timeout for this call
					const existingTimeout = autoCloseTimeoutRef.current.get(callIdentifier);
					if (existingTimeout) {
						clearTimeout(existingTimeout);
					}

					// Set a debounced timeout to handle the auto-close
					const timeout = setTimeout(() => {
						console.log("Auto-closing lead after debounce:", callIdentifier);
						handleAutomaticallyCloseLead(patientId, prescriptionId, customerNumber);

						// Clean up after processing
						autoCloseTimeoutRef.current.delete(callIdentifier);

						// Remove from processed calls after a longer timeout to prevent immediate re-processing
						setTimeout(() => {
							processedCallsRef.current.delete(callIdentifier);
						}, 30000); // 30 seconds cleanup delay

					}, 2000); // 2 second debounce

					autoCloseTimeoutRef.current.set(callIdentifier, timeout);

					// Reset customer number
					customerNumberRef.current = null;
				}
			}

			if (isAnyModalOpen()) {
				console.log("Skipping data refresh knowlarity- modal is open:", modalStatesRef.current);
				return;
			}

			if (captureResponseModal || closeLeadModal || successMsgModal || agentModal) {
				console.log("Skipping data refresh - modal is open:", {
					captureResponseModal,
					closeLeadModal,
					successMsgModal,
					agentModal
				});
				return;
			}

			// Clear existing timeout
			if (debounceTimeoutRef.current) {
				clearTimeout(debounceTimeoutRef.current);
			}

			// Set new timeout for debouncing data refresh
			debounceTimeoutRef.current = setTimeout(() => {
				if (captureResponseModal || closeLeadModal || successMsgModal || agentModal) {
					console.log("Skipping data refresh - modal opened while timeout was pending");
					return;
				}

				console.log("Executing data refresh after knowlarity event");
				// ðŸ”¥ Pass preserveScroll=true for websocket events
				getHighOrderValueData(true);
				setTimeout(() => {
					getCampaignNumbersData();
				}, 2000);
			}, 300);
		} catch (error) {
			console.error('Error handling knowlarity event:', error);
		}
	}, [getHighOrderValueData, getCampaignNumbersData]);

	const handleCloseLead = (value: any) => {
		// Clear any pending timeouts when modal opens
		if (debounceTimeoutRef.current) {
			clearTimeout(debounceTimeoutRef.current);
			debounceTimeoutRef.current = null;
		}
		setCloseLeadModal(true)
		setRowDataCL(value)
	}

	const handleConfirmCloseLead = async (rowDataCL: any) => {
		try {
			const res = await hightOrderCaptureResponse({
				patientId: rowDataCL?.patientId,
				prescriptionId: rowDataCL?.prescriptionId,
				followUpStatus: "No"
			});

			if (res?.statusCode === 201) {
				// Same pattern: unlock first, then refresh
				await unlockingOrder(rowDataCL);
				await getHighOrderValueData();
				setSuccessMsgModal(true);
			}
		} catch (error) {
			handleApiError(error);
		} finally {
			setCloseLeadModal(false);
		}
	};

	//open capturing response modal
	const handleCaptureResponse = (value: any) => {
		// Clear any pending timeouts when modal opens
		if (debounceTimeoutRef.current) {
			clearTimeout(debounceTimeoutRef.current);
			debounceTimeoutRef.current = null;
		}
		setCaptureResponseModal(true)
		setRowDataCR(value)
	}

	const handleAutomaticallyCloseLead = async (patientId: string, prescriptionId: string, customerNumber: string) => {
		try {
			// Additional validation to prevent unnecessary API calls
			if (!patientId || !prescriptionId || !customerNumber) {
				console.warn("Missing required parameters for auto-close:", { patientId, prescriptionId, customerNumber });
				return;
			}

			console.log("Automatically closing lead for:", { patientId, prescriptionId, customerNumber });

			const res = await hightOrderCaptureResponse({
				comments: "Ringing No Answer and system automatically closed lead",
				patientId,
				prescriptionId,
				followUpStatus: "No",
				callDisposition: "Non-contact",
				serviceDispositionL1: "Ringing no Response",
				serviceDispositionL2: "",
				dnd: false,
				mobileNo: customerNumber,
			});

			if (res.success || res?.statusCode === 201) {
				console.log("Lead auto-closed successfully for:", { patientId, prescriptionId });
				getHighOrderValueData();
				setCaptureResponseModal(false);
			} else {
				console.error("Failed to auto-close lead:", res);
			}
		} catch (error) {
			console.error("Error in handleAutomaticallyCloseLead:", error);
			handleApiError(error);
		}
	}

	const handleSubmitCaptureResponse = async (
		updatedReason: any,
		valueFollowups: any,
		followUpDate: any,
		valueTime: any,
		selectedCD: any,
		selectedL1: any,
		selectedL2: any,
		additionalComment: string,
		dnd: boolean,
		mobileNo: string
	) => {
		try {
			const res = await hightOrderCaptureResponse({
				comments: additionalComment,
				patientId: rowDataCR?.patientId,
				prescriptionId: rowDataCR?.prescriptionId,
				orderId: rowDataCR?.orderId,
				followUpStatus: valueFollowups,
				...(followUpDate && { followUpDate }),
				callDisposition: selectedCD,
				serviceDispositionL1: selectedL1,
				serviceDispositionL2: selectedL2,
				timings: valueTime?.format("hh:mm A"),
				dnd,
				mobileNo,
			});
			if (res.success || res?.statusCode === 201) {
				getHighOrderValueData();
				setCaptureResponseModal(false);
				if (dnd === false) {
					setModalType("capture");
					setSuccessMsgModal(true);
				} else {
					setModalType("dnd");
					setSuccessMsgModal(true);
				}
			}
		} catch (error) {
			handleApiError(error);
		}
	};

	//unlocking order
	const unlockingOrder = async (row: any) => {
		try {
			const res = await unlockCallCenterOrder({
				"patientId": row?.patientId,
				"prescriptionId": row?.prescriptionId,
				"name": tab,
			})
		}
		catch (error) {
			handleApiError(error);
		}
	}

	//closing capture response modal
	const closingCaptureResponseModal = async (row: any) => {
		try {
			await unlockingOrder(row);
			await getHighOrderValueData();
		} catch (error) {
			console.error("Error closing capture response modal:", error);
			handleApiError("Failed to unlock order");
		} finally {
			setCaptureResponseModal(false);
		}
	}

	//closing close lead modal
	const closingCloseLeadModal = async () => {
		try {
			await unlockingOrder(rowDataCL);
			await getHighOrderValueData();
		} catch (error) {
			console.error("Error closing lead modal:", error);
			handleApiError("Failed to unlock order");
		} finally {
			setCloseLeadModal(false);
		}
	}

	const handleAgentNumber = () => {
		setCookie("agent_number", agentNumber);
		setAgentModal(false);
	}

	// Add function to load more data
	const handleLoadMore = React.useCallback(async () => {
		// ðŸ”¥ Better condition checking
		if (isLoadingMore || tableData.length >= totalRecords) {
			console.log("Load more skipped:", {
				isLoadingMore,
				tableLength: tableData.length,
				totalRecords,
				reason: isLoadingMore ? "Already loading" : "All data loaded"
			});
			return;
		}

		console.log("ðŸš€ Loading more data...", {
			currentLength: tableData.length,
			totalRecords,
			nextPage: Math.ceil(tableData.length / 10) + 1
		});

		setIsLoadingMore(true);
		setLoadingProgress(0);



		// Progress simulation
		const progressInterval = setInterval(() => {
			setLoadingProgress(prev => {
				if (prev >= 90) {
					clearInterval(progressInterval);
					return 90;
				}
				return prev + Math.random() * 20;
			});
		}, 100);

		try {
			// ðŸ”¥ Calculate next page more accurately
			const currentPage = Math.floor(tableData.length / 10) + 1;

			console.log(`ðŸ“¡ Fetching page ${currentPage} with limit 10...`);

			// const response = await getHighOrderValue({
			// 	leadStatus: filters.leadStatus,
			// 	page: currentPage,
			// 	limit: 10,
			// 	department: filters.dept,
			// 	searchString: filters.searchString,
			// 	date: filters.date,
			// 	unit: filters.unit,
			// 	campaign: filters.campaign,
			// 	call_status: filters.call_status
			// });

			const response = await getCampaignsList({
				leadStatus: filters.leadStatus,
				page: currentPage,
				limit: 10,
				searchString: filters.searchString || '',
				unit: filters.unit || 'ALL',
				department: filters.dept || 'ALL',
				category: 'ALL',
				source: filters.source || 'ALL'
			});


			if (response.success && response.data?.data) {
				const newRecords = response.data.data;
				console.log("âœ… New data received:", {
					recordCount: newRecords.length,
					totalAvailable: response.data.totalRecords
				});

				setLoadingProgress(100);

				setTimeout(() => {
					setTableData(prev => {
						// ðŸ”¥ Prevent duplicate records
						const existingIds = new Set(prev.map(item => `${item.patientId}_${item.prescriptionId}`));
						const uniqueNewRecords = newRecords.filter(
							(record: any) => !existingIds.has(`${record.patientId}_${record.prescriptionId}`)
						);

						const newData = [...prev, ...uniqueNewRecords];
						console.log("ðŸ“Š Data updated:", {
							previous: prev.length,
							newUnique: uniqueNewRecords.length,
							total: newData.length,
							totalRecords: response.data.totalRecords
						});

						return newData;
					});

					// ðŸ”¥ Update total records if it changed
					if (response.data.totalRecords !== totalRecords) {
						setTotalRecords(response.data.totalRecords);
					}

					setTimeout(() => setLoadingProgress(0), 500);
				}, 300);
			} else {
				console.error("âŒ API Error:", response.message);
				clearInterval(progressInterval);
				setLoadingProgress(0);
			}
		} catch (error) {
			console.error("âŒ Network Error:", error);
			clearInterval(progressInterval);
			setLoadingProgress(0);
		} finally {
			setTimeout(() => {
				setIsLoadingMore(false);
			}, 800);
		}
	}, [isLoadingMore, tableData.length, totalRecords, filters]);

	// Set up WebSocket event listeners
	React.useEffect(() => {
		console.log('Setting up WebSocket event listeners...');
		// Listen for knowlarity events
		on('knowlarityEvent', (message: WebSocketMessage) => {
			console.log('Knowlarity event received:', message);
			handleKnowlarityEvent(message.data.event || message.data);
		});

		// Test connection after a delay
		const testConnection = setTimeout(() => {
			if (!isConnected) {
				console.warn('WebSocket not connected after 5 seconds. Check if the server is running.');
				console.log('Expected URL:', `${process.env.NEXT_PUBLIC_PRESCRIPTION_SERVICE_URL || 'http://localhost:4020'}/calleragent`);
			} else {
				console.log('WebSocket is connected and ready for real-time updates');
			}
		}, 5000);

		return () => clearTimeout(testConnection);
	}, [on, isConnected]);

	// Effect to reset page when filters change
	React.useEffect(() => {
		setPageNumberClicked(1);
		setItemSelected([]);
	}, [filters.leadStatus, filters.dept, filters.searchString, filters.date, filters.unit]);

	// Effect to fetch high value order when filters, page, or page size change
	React.useEffect(() => {
		getHighOrderValueData(false); // Don't preserve scroll on initial load or filter changes
		getCampaignNumbersData();
	}, [filters, pageNumberClicked, pageSize]);

	React.useEffect(() => {
		const _agentNumber = getCookie("agent_number")
		if (_agentNumber) {
			setAgentNumber(_agentNumber);
		} else {
			setAgentModal(true);
		}
	}, [agentNumber])

	// Clean up timeouts on component unmount
	React.useEffect(() => {
		return () => {
			// Clean up debounce timeout
			if (debounceTimeoutRef.current) {
				clearTimeout(debounceTimeoutRef.current);
			}

			// Clean up all auto-close timeouts
			autoCloseTimeoutRef.current.forEach((timeout) => {
				clearTimeout(timeout);
			});
			autoCloseTimeoutRef.current.clear();

			// Clear processed calls
			processedCallsRef.current.clear();
		};
	}, []);

	return (
		<>
			{/* ðŸ”¥ Add loading progress indicator */}
			{isLoadingMore && (
				<Box
					sx={{
						position: 'fixed',
						top: 0,
						left: 0,
						right: 0,
						height: 3,
						zIndex: 9999,
						background: `linear-gradient(90deg, 
              transparent 0%, 
              #1976d2 ${loadingProgress}%, 
              transparent ${loadingProgress + 10}%
            )`,
						animation: 'shimmer 1.5s ease-in-out infinite',
						'@keyframes shimmer': {
							'0%': { backgroundPosition: '-100px 0' },
							'100%': { backgroundPosition: 'calc(100% + 100px) 0' }
						}
					}}
				/>
			)}

			<AgentModal agentModal={agentModal} setAgentModal={setAgentModal} setAgentNumber={setAgentNumber} handleAgentNumber={handleAgentNumber} />

			<Box sx={{ display: "flex", justifyContent: "space-between", alignItems: "center", mb: 2 }}>
				{/* WebSocket Connection Status */}
				{/* <Box sx={{ display: "flex", alignItems: "center", gap: 1, ml: 1 }}>
					<Box
						sx={{
							width: 8,
							height: 8,
							borderRadius: '50%',
							backgroundColor: isConnected ? 'success.main' : 'error.main',
							animation: isConnected ? 'pulse 2s infinite' : 'none',
							'@keyframes pulse': {
								'0%': { opacity: 1 },
								'50%': { opacity: 0.5 },
								'100%': { opacity: 1 },
							},
						}}
					/>
					<Typography variant="caption" sx={{ color: isConnected ? 'success.main' : 'error.main' }}>
						{isConnected ? 'Online' : 'Offline'}
					</Typography>
				</Box> */}
			</Box>

			<Box
				sx={{
					bgcolor: theme.palette.primary.light,
					display: "flex",
					height: "100%"
				}}
			>
				<PageContainer>
					<Box
						sx={{
							display: "flex",
							alignItems: "flex-start",
							justifyContent: "flex-start",
						}}
					>
						<React.Fragment>
							<CampaignsList
								selected={itemSelected}
								setItemSelected={setItemSelected}
								tableData={tableDataWithKey}
								isLoading={isLoading}
								agentNumber={agentNumber}
								campaignNumbers={campaignNumbers}
								pageNumberClicked={pageNumberClicked}
								setPageNumberClicked={(page: number) => setPageNumberClicked(page)}
								recordsToShow={pageSize}
								setRecordsToShow={(ps: number) => setPageSize(ps)}
								totalRecords={totalRecords}
								setTotalRecords={setTotalRecords}
								getConversionPendingData={''}
								handleCloseLead={handleCloseLead}
								handleCaptureResponse={handleCaptureResponse}
								tab={tab}
								onLoadMore={handleLoadMore}
								onScrollHandlersReady={handleScrollHandlersReady} // ðŸ”¥ Add this prop
							/>
						</React.Fragment>

						<Modal
							open={closeLeadModal}
							onClose={closingCloseLeadModal}
							sx={modalStyles}
						>
							<Box sx={modalContainerStyles}>
								{/* Warning Icon */}
								<Box sx={{
									...iconContainerStyles,
									backgroundColor: "rgba(255, 152, 0, 0.1)",
									border: "2px solid",
									borderColor: "warning.main"
								}}>
									<ErrorOutlineIcon sx={{ color: "warning.main", fontSize: "1.5rem" }} />
								</Box>

								<Typography variant="subtitle1" fontWeight={600} color="text.primary" sx={{ mb: 1 }}>
									Confirm Lead Closure
								</Typography>

								<Typography variant="body2" color="text.secondary" sx={{ mb: 2, lineHeight: 1.4 }}>
									Are you sure you want to close this lead? This action cannot be undone.
								</Typography>

								<Box display="flex" justifyContent="center" gap={1.5} sx={{ width: "100%" }}>
									<Button
										onClick={closingCloseLeadModal}
										variant="outlined"
										sx={{
											...secondaryButtonStyles,
											borderColor: "grey.400",
											color: "text.secondary",
											'&:hover': {
												borderColor: "grey.600",
												backgroundColor: "grey.50"
											}
										}}
									>
										Cancel
									</Button>
									<Button
										onClick={() => handleConfirmCloseLead(rowDataCL)}
										variant="contained"
										sx={{
											...primaryButtonStyles,
											backgroundColor: "warning.main",
											'&:hover': {
												backgroundColor: "warning.dark"
											}
										}}
									>
										Close Lead
									</Button>
								</Box>
							</Box>
						</Modal>

						{/* Unified Success/DND Modal */}
						<Modal
							open={successMsgModal}
							onClose={() => setSuccessMsgModal(false)}
							sx={modalStyles}
						>
							<Box sx={modalContainerStyles}>
								{/* Dynamic Icon */}
								<Box
									sx={{
										...iconContainerStyles,
										backgroundColor:
											modalType === "dnd"
												? "rgba(244, 67, 54, 0.1)"
												: modalType === "capture" || modalType === "close"
													? "rgba(76, 175, 80, 0.1)"
													: "rgba(33, 150, 243, 0.1)",
										border: "2px solid",
										borderColor:
											modalType === "dnd"
												? "error.main"
												: modalType === "capture" || modalType === "close"
													? "success.main"
													: "info.main",
									}}
								>
									{modalType === "dnd" ? (
										<WarningAmberIcon sx={{ color: "error.main", fontSize: "1.5rem" }} />
									) : (
										<CheckCircleOutlineIcon sx={{ color: "success.main", fontSize: "1.5rem" }} />
									)}
								</Box>

								{modalType === "close" && (
									<>
										<Typography variant="subtitle1" fontWeight={600} color="success.main" sx={{ mb: 1 }}>
											Lead Closed Successfully!
										</Typography>
										<Typography variant="body2" color="text.secondary" sx={{ lineHeight: 1.4 }}>
											The lead has been closed and saved in the system.
										</Typography>
									</>
								)}

								{modalType === "capture" && (
									<>
										<Typography variant="h6" fontWeight="bold" color="success.main">
											Response Captured Successfully!
										</Typography>
										<Typography variant="body2" color="text.secondary">
											The patientâ€™s response has been recorded.
										</Typography>
									</>
								)}

								{modalType === "dnd" && (
									<>
										<Typography variant="subtitle1" fontWeight={600} color="error.main" sx={{ mb: 1 }}>
											DND Enabled!
										</Typography>
										<Typography variant="body2" color="text.secondary" sx={{ lineHeight: 1.4 }}>
											DND has been enabled for patient {rowDataCR?.patientId}.
										</Typography>
									</>
								)}

								<Button
									onClick={() => setSuccessMsgModal(false)}
									variant="contained"
									sx={{
										...primaryButtonStyles,
										mt: 1.5,
										backgroundColor: modalType === "dnd" ? "error.main" : "success.main",
										'&:hover': {
											backgroundColor: modalType === "dnd" ? "error.dark" : "success.dark",
										}
									}}
								>
									OK
								</Button>
							</Box>
						</Modal>

						{/* Capture Response */}
						<DispositionFormCA
							open={captureResponseModal}
							onClose={() => closingCaptureResponseModal(rowDataCR)}
							handleSubmitCapture={handleSubmitCaptureResponse}
							rowData={rowDataCR} />
					</Box>
				</PageContainer>
			</Box>
		</>
	);
};

export default Campaigns;


import * as React from "react";
import ReactDOMServer from "react-dom/server";
import {
  Typography,
  Table,
  TableContainer,
  TableBody,
  TableRow,
  TableCell,
  Box,
  Paper,
  Checkbox,
  CircularProgress,
} from "@mui/material";
import styles from "./style.module.scss";
import { Order, PaginatedTableProps } from "./table.d";
import EnhancedTableHead from "./head";
import Row from "./collapsible_row";
import { getComparator, getSum, stableSort } from "./helpers";
import HtmlTable from "./html_table";
import NoData from "./NoData";
import { useRouter } from "next/router";

const ScrollableTable = (props: PaginatedTableProps) => {
  const [order, setOrder] = React.useState<Order>("asc");
  const [orderBy, setOrderBy] = React.useState<string>("");
  const [totalColSpan, setTotalColSpan] = React.useState<any>(0);
  const [htmlTable, setHtmlTable] = React.useState<any>("");
  const [isPrintClicked, setPrintClicked] = React.useState<boolean>(false);
  const [isExcelClicked, setExcelClicked] = React.useState<boolean>(false);
  const [expandedRowId, setExpandedRowId] = React.useState<string | null>(null);

  // Infinite scroll state
  const [visibleCount, setVisibleCount] = React.useState(10);
  const [isLoadingMore, setIsLoadingMore] = React.useState(false);
  const [showScrollIndicator, setShowScrollIndicator] = React.useState(false);
  const loaderRef = React.useRef<HTMLDivElement | null>(null);
  const tableContainerRef = React.useRef<HTMLDivElement | null>(null);

  const router = useRouter();
  const { locale } = router;

  const {
    expandable,
    expandInCols,
    serialNo,
    rows,
    headCells,
    expandIconAt,
    uniqueKey,
    actions,
    loading,
    tableRef,
    tableTitle,
    excelFileName,
    order: orderProps,
    orderBy: orderByProps,
    showTotal,
    selectable,
    selected,
    setSelected,
    viewlabel,
    coloumnNumber,
    agentNumber,
    // Add these new props for infinite scroll
    hasMore = false,
    onLoadMore,
    totalLength,
  } = props;

  const lengthOfData = rows?.length || 0;

  const handleToggleExpand = (rowId: string) => {
    setExpandedRowId(prev => (prev === rowId ? null : rowId));
  };

  // Colspan setup
  React.useEffect(() => {
    setTotalColSpan(
      1 +
        (selectable ? 1 : 0) +
        (serialNo ? 1 : 0) +
        (expandIconAt === "start" ? 1 : 0)
    );
  }, [showTotal]);

  // External order props
  React.useEffect(() => {
    if (orderProps) setOrder(orderProps);
  }, [orderProps]);

  React.useEffect(() => {
    if (orderByProps) setOrderBy(orderByProps);
  }, [orderByProps]);

  // Export logic
  React.useEffect(() => {
    if (headCells && rows.length > 0) {
      const htmlTableSample = ReactDOMServer.renderToString(
        <HtmlTable
          headCells={headCells}
          rows={rows}
          uniqueKey={`row-${uniqueKey}-${rows[0]}`}
          title={tableTitle}
        />
      );
      setHtmlTable(htmlTableSample);
    }
  }, [rows, headCells]);

  const base64 = (s: any) => window.btoa(unescape(encodeURIComponent(s)));
  React.useEffect(() => {
    if (isPrintClicked) {
      const printWindow = window.open("", "", "width=800,height=600");
      if (printWindow) {
        printWindow.document.write(htmlTable);
        printWindow.document.close();
        setTimeout(() => {
          printWindow.focus();
          printWindow.print();
        }, 500);
      }
    }
  }, [isPrintClicked]);

  React.useEffect(() => {
    if (isExcelClicked) {
      const uri = "data:application/vnd.ms-excel;base64,";
      const template = `<html xmlns:o="urn:schemas-microsoft-com:office:office" 
        xmlns:x="urn:schemas-microsoft-com:office:excel" 
        xmlns="http://www.w3.org/TR/REC-html40">
        <head><meta http-equiv="content-type" content="text/plain; charset=UTF-8"/></head>
        <body>${htmlTable}</body></html>`;
      const a = window.document.createElement("a");
      a.href = uri + base64(template);
      a.download = `${excelFileName}.xls`;
      a.click();
    }
  }, [isExcelClicked]);

  const print = () => setPrintClicked(true);
  const exportToExcel = () => setExcelClicked(true);

  React.useEffect(() => {
    if (tableRef) tableRef.current = { print, exportToExcel };
  }, []);

  const handleRequestSort = (
    event: React.MouseEvent<unknown>,
    property: string
  ) => {
    const isAsc = orderBy === property && order === "asc";
    setOrder(isAsc ? "desc" : "asc");
    setOrderBy(property);
  };

  const handleSelectAllClick = (event: any) => {
    if (event.target.checked) {
      const newSelecteds = rows.map(n => n[uniqueKey].toString());
      setSelected && setSelected(newSelecteds);
      return;
    }
    setSelected && setSelected([]);
  };

  const handleClick = (event: React.MouseEvent<unknown>, name: string) => {
    const selectedIndex = selected.indexOf(name);
    let newSelected: readonly string[] = [];

    if (selectedIndex === -1) {
      newSelected = newSelected.concat(selected, name);
    } else if (selectedIndex === 0) {
      newSelected = newSelected.concat(selected.slice(1));
    } else if (selectedIndex === selected.length - 1) {
      newSelected = newSelected.concat(selected.slice(0, -1));
    } else if (selectedIndex > 0) {
      newSelected = newSelected.concat(
        selected?.slice(0, selectedIndex),
        selected?.slice(selectedIndex + 1)
      );
    }
    setSelected && setSelected(newSelected);
  };

  const isSelected = (name: string) => selected.includes(name);

  // ðŸ”¥ Enhanced infinite scroll effect with better data fetching logic
  React.useEffect(() => {
    if (typeof window !== "undefined" && "IntersectionObserver" in window && onLoadMore) {
      const observer = new window.IntersectionObserver(
        (entries) => {
          const target = entries[0];
          // ðŸ”¥ Add additional check to prevent multiple calls
          if (target.isIntersecting && !isLoadingMore && !showScrollIndicator) {
            const canShowMore = visibleCount < rows.length;
            const canFetchMore = rows.length < totalLength && hasMore;
            
            if (!canShowMore && !canFetchMore) {
              return; // Nothing to do
            }
            
            console.log("ðŸ”„ Intersection triggered:", { canShowMore, canFetchMore, visibleCount, rowsLength: rows.length, totalLength });
            
            if (canShowMore) {
              // Show more existing data - this works fine
              console.log(`ðŸ“‹ Showing more existing data: ${visibleCount} -> ${Math.min(visibleCount + 10, rows.length)}`);
              
              setIsLoadingMore(true);
              setShowScrollIndicator(true);
              
              setTimeout(() => {
                setVisibleCount(prev => {
                  const newCount = Math.min(prev + 10, rows.length);
                  
                  // Only trigger server fetch when we've shown ALL loaded data
                  if (newCount >= rows.length && rows.length < totalLength && hasMore) {
                    console.log("ðŸ“¡ All loaded data shown, triggering server fetch");
                    // ðŸ”¥ KEY FIX: Reset loading states BEFORE calling onLoadMore
                    setTimeout(() => {
                      setIsLoadingMore(false);
                      setShowScrollIndicator(false);
                      onLoadMore?.();
                    }, 100);
                  } else {
                    setIsLoadingMore(false);
                    setShowScrollIndicator(false);
                  }
                  
                  return newCount;
                });
              }, 150);
              
            } else if (canFetchMore) {
              // ðŸ”¥ KEY FIX: Don't manage isLoadingMore here - let parent handle it
              console.log(`ðŸ“¡ Calling onLoadMore for server fetch: ${rows.length}/${totalLength}`);
              setShowScrollIndicator(true);
              
              // ðŸ”¥ Call onLoadMore immediately without setting isLoadingMore
              onLoadMore?.();
              
              // ðŸ”¥ Only manage the scroll indicator, not isLoadingMore
              setTimeout(() => {
                setShowScrollIndicator(false);
              }, 1000);
            }
          }
        },
        { 
          threshold: 0.1,
          rootMargin: '50px'
        }
      );

      if (loaderRef.current) {
        observer.observe(loaderRef.current);
      }

      return () => {
        observer.disconnect();
      };
    }
  }, [rows.length, visibleCount, isLoadingMore, hasMore, onLoadMore, totalLength, showScrollIndicator]);

  // ðŸ”¥ Reset visible count when new data is loaded
  React.useEffect(() => {
    if (rows.length > 0 && visibleCount > rows.length) {
      console.log(`Adjusting visible count from ${visibleCount} to ${rows.length} based on loaded data`);
      setVisibleCount(rows.length);
    }
  }, [rows.length]);

  const visibleRows = stableSort(rows, getComparator(order, orderBy)).slice(
    0,
    visibleCount
  );

  // ðŸ”¥ Add scroll position preservation
  const scrollPositionRef = React.useRef<number>(0);
  const shouldPreserveScrollRef = React.useRef<boolean>(false);
  
  // Save scroll position before data updates
  const saveScrollPosition = React.useCallback(() => {
    if (tableContainerRef.current) {
      scrollPositionRef.current = tableContainerRef.current.scrollTop;
      shouldPreserveScrollRef.current = true;
      console.log('ðŸ“ Scroll position saved:', scrollPositionRef.current);
    }
  }, []);

  // Restore scroll position after data updates
  const restoreScrollPosition = React.useCallback(() => {
    if (shouldPreserveScrollRef.current && tableContainerRef.current) {
      const savedPosition = scrollPositionRef.current;
      
      // Use requestAnimationFrame to ensure DOM is updated
      requestAnimationFrame(() => {
        if (tableContainerRef.current) {
          tableContainerRef.current.scrollTop = savedPosition;
          console.log('ðŸ“ Scroll position restored:', savedPosition);
          shouldPreserveScrollRef.current = false;
        }
      });
    }
  }, []);

  // ðŸ”¥ Expose scroll position methods via props
  React.useEffect(() => {
    if (props.onScrollPositionChange) {
      props.onScrollPositionChange({
        saveScrollPosition,
        restoreScrollPosition
      });
    }
  }, [saveScrollPosition, restoreScrollPosition, props.onScrollPositionChange]);

  // ðŸ”¥ Monitor scroll position changes
  const handleScroll = React.useCallback((event: React.UIEvent<HTMLDivElement>) => {
    const target = event.currentTarget;
    scrollPositionRef.current = target.scrollTop;
  }, []);

  // ðŸ”¥ Restore scroll position when rows change (but not during initial load)
  React.useEffect(() => {
    if (rows.length > 0 && shouldPreserveScrollRef.current) {
      // Small delay to ensure DOM is fully rendered
      const timeoutId = setTimeout(() => {
        restoreScrollPosition();
      }, 50);
      
      return () => clearTimeout(timeoutId);
    }
  }, [rows, restoreScrollPosition]);

  return (
    <Box sx={{ width: "100%", position: 'relative' }}>
      {/* ðŸ”¥ Add smooth scroll indicator */}
      {showScrollIndicator && (
        <Box
          sx={{
            position: 'absolute',
            top: 0,
            left: 0,
            right: 0,
            height: 4,
            zIndex: 1000,
            background: 'linear-gradient(90deg, transparent, #1976d2, transparent)',
            animation: 'slideProgress 1.5s ease-in-out infinite',
            '@keyframes slideProgress': {
              '0%': { transform: 'translateX(-100%)' },
              '100%': { transform: 'translateX(100%)' }
            }
          }}
        />
      )}

      <Paper
        elevation={2}
        sx={{
          borderRadius: ".5rem",
          boxShadow: "none",
          border: "1px solid #ECECEC",
          position: 'relative',
          overflow: 'hidden'
        }}
      >
        <TableContainer 
          ref={tableContainerRef}
          onScroll={handleScroll} // ðŸ”¥ Add scroll handler
          sx={{ 
            maxHeight: '70vh', 
            overflow: 'auto',
            scrollBehavior: 'auto', // ðŸ”¥ Changed from 'smooth' to 'auto' for position restoration
            position: 'relative',
            '&::-webkit-scrollbar': {
              width: '8px',
            },
            '&::-webkit-scrollbar-track': {
              background: '#f1f1f1',
              borderRadius: '4px',
            },
            '&::-webkit-scrollbar-thumb': {
              background: '#c1c1c1',
              borderRadius: '4px',
              '&:hover': {
                background: '#a8a8a8',
              }
            }
          }}
        >
          <Table sx={{ minWidth: 750 }} size="small" stickyHeader>
            {/* ðŸ”¥ Enhanced table header with opaque background */}
            <EnhancedTableHead
              order={order}
              orderBy={orderBy}
              onRequestSort={handleRequestSort}
              headCells={headCells}
              serialNo={serialNo}
              expandIconAt={expandIconAt}
              selectable={selectable}
              onSelectAllClick={handleSelectAllClick}
              numSelected={selected?.length}
              rowCount={lengthOfData}
              viewlabel={viewlabel}
              sx={{
                '& .MuiTableCell-head': {
                  backgroundColor: '#ffffff', // ðŸ”¥ Opaque white background
                  backdropFilter: 'blur(10px)', // ðŸ”¥ Add blur effect for better visibility
                  borderBottom: '2px solid #e0e0e0',
                  fontWeight: 600,
                  fontSize: '0.875rem',
                  color: 'text.primary',
                  position: 'sticky',
                  top: 0,
                  zIndex: 1100, // ðŸ”¥ Higher z-index to stay above content
                  boxShadow: '0 2px 4px rgba(0,0,0,0.1)', // ðŸ”¥ Add shadow for depth
                }
              }}
            />
            <TableBody>
              {/* ðŸ”¥ Enhanced record counter with opaque background */}
              <TableRow>
                <TableCell 
                  colSpan={headCells.length + (serialNo ? 1 : 0) + (selectable ? 1 : 0)} 
                  sx={{ 
                    backgroundColor: 'rgba(255, 255, 255, 0.95)', // ðŸ”¥ More opaque background
                    backdropFilter: 'blur(8px)', // ðŸ”¥ Add blur for better visibility
                    fontWeight: 500,
                    fontSize: '0.875rem',
                    textAlign: 'center',
                    padding: '12px',
                    borderBottom: '2px solid rgba(25, 118, 210, 0.1)',
                    position: 'sticky',
                    top: 56, // ðŸ”¥ Stick below header
                    zIndex: 1000, // ðŸ”¥ High z-index
                    boxShadow: '0 1px 3px rgba(0,0,0,0.08)', // ðŸ”¥ Subtle shadow
                  }}
                >
                  <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                    <Typography variant="body2" color="primary.main">
                      Showing {Math.min(visibleCount, rows.length)} of {rows.length} loaded
                    </Typography>
                    <Typography variant="body2" color="text.secondary">
                      {rows.length} / {totalLength || rows.length} total records
                    </Typography>
                  </Box>
                </TableCell>
              </TableRow>



              {visibleRows.map((row, index) => {
                const isItemSelected = isSelected(row[uniqueKey]?.toString());
                return expandable ? (
                  <Row
                    key={row[uniqueKey]}
                    expandedRowId={expandedRowId}
                    onToggleExpand={handleToggleExpand}
                    row={row}
                    agentNumber={agentNumber}
                    headCells={headCells}
                    expand={expandable}
                    expandInCols={expandInCols}
                    expandIconAt={expandIconAt}
                    serialNo={serialNo ? index + 1 : undefined}
                    coloumnNumber={coloumnNumber}
                    selectable={
                      selectable && (
                        <TableCell
                          className={styles.stickyLeft}
                          padding="checkbox"
                          sx={{ p: "1rem", left: 0, textAlign: "center" }}
                        >
                          <Checkbox
                            color="primary"
                            checked={isItemSelected}
                            onClick={event =>
                              handleClick(event, row[uniqueKey].toString())
                            }
                          />
                        </TableCell>
                      )
                    }
                  />
                ) : (
                  <TableRow 
                    key={row[uniqueKey]}
                    sx={{
                      '&:hover': {
                        backgroundColor: 'rgba(25, 118, 210, 0.04)',
                        transition: 'background-color 0.2s ease'
                      }
                    }}
                  >
                    {selectable && (
                      <TableCell padding="checkbox" sx={{ p: "1rem" }}>
                        <Checkbox
                          color="primary"
                          checked={isItemSelected}
                          onClick={event =>
                            handleClick(event, row[uniqueKey].toString())
                          }
                        />
                      </TableCell>
                    )}
                    {serialNo && <TableCell>{index + 1}</TableCell>}
                    {headCells.map(headCell => (
                      <TableCell
                        key={headCell.id}
                        className={
                          headCell.stickyClass ? styles[headCell.stickyClass] : ""
                        }
                        sx={{
                          fontSize: "0.875rem",
                          left: headCell.stickyAt,
                          right: headCell.stickyAt,
                        }}
                      >
                        {headCell.cell ? headCell.cell(row) : row[headCell.id]}
                      </TableCell>
                    ))}
                  </TableRow>
                );
              })}

              {/* ðŸ”¥ Update loading condition */}
              {(isLoadingMore || showScrollIndicator) && (
                <TableRow>
                  <TableCell colSpan={headCells.length + (serialNo ? 1 : 0) + (selectable ? 1 : 0)} align="center">
                    <Box sx={{ 
                      p: 3,
                      display: 'flex',
                      flexDirection: 'column',
                      alignItems: 'center',
                      gap: 1.5,
                      background: 'linear-gradient(135deg, rgba(25, 118, 210, 0.05) 0%, rgba(25, 118, 210, 0.02) 100%)',
                      borderRadius: 2,
                      margin: 1,
                      animation: 'fadeInUp 0.3s ease-out',
                      '@keyframes fadeInUp': {
                        '0%': { opacity: 0, transform: 'translateY(20px)' },
                        '100%': { opacity: 1, transform: 'translateY(0)' }
                      }
                    }}>
                      <Box
                        sx={{
                          position: 'relative',
                          display: 'inline-flex',
                          alignItems: 'center',
                          justifyContent: 'center'
                        }}
                      >
                        <CircularProgress 
                          size={32} 
                          thickness={3}
                          sx={{
                            color: 'primary.main',
                            animation: 'spin 1s linear infinite',
                            '@keyframes spin': {
                              '0%': { transform: 'rotate(0deg)' },
                              '100%': { transform: 'rotate(360deg)' }
                            }
                          }}
                        />
                        <Box
                          sx={{
                            position: 'absolute',
                            top: 0,
                            left: 0,
                            bottom: 0,
                            right: 0,
                            display: 'flex',
                            alignItems: 'center',
                            justifyContent: 'center',
                          }}
                        >
                          <Box
                            sx={{
                              width: 8,
                              height: 8,
                              borderRadius: '50%',
                              backgroundColor: 'primary.main',
                              animation: 'pulse 1.5s ease-in-out infinite',
                              '@keyframes pulse': {
                                '0%': { transform: 'scale(0.8)', opacity: 0.7 },
                                '50%': { transform: 'scale(1.2)', opacity: 1 },
                                '100%': { transform: 'scale(0.8)', opacity: 0.7 }
                              }
                            }}
                          />
                        </Box>
                      </Box>
                      <Typography 
                        variant="body2" 
                        color="primary.main"
                        sx={{ 
                          fontWeight: 500,
                          animation: 'fadeIn 0.5s ease-out 0.2s both',
                          '@keyframes fadeIn': {
                            '0%': { opacity: 0 },
                            '100%': { opacity: 1 }
                          }
                        }}
                      >
                        Loading next 10 records...
                      </Typography>
                      <Box
                        sx={{
                          width: '60px',
                          height: '2px',
                          backgroundColor: 'primary.main',
                          borderRadius: '1px',
                          animation: 'expand 1.5s ease-in-out infinite',
                          '@keyframes expand': {
                            '0%': { width: '20px', opacity: 0.5 },
                            '50%': { width: '60px', opacity: 1 },
                            '100%': { width: '20px', opacity: 0.5 }
                          }
                        }}
                      />
                    </Box>
                  </TableCell>
                </TableRow>
              )}

              {/* ðŸ”¥ Update sentinel condition - show when there are more records to display OR fetch */}
              {((visibleCount < rows.length) || (hasMore && rows.length < totalLength)) && !isLoadingMore && !showScrollIndicator && (
                <TableRow ref={loaderRef}>
                  <TableCell 
                    colSpan={headCells.length + (serialNo ? 1 : 0) + (selectable ? 1 : 0)}
                    sx={{ 
                      height: '40px',
                      background: 'linear-gradient(to bottom, transparent, rgba(25, 118, 210, 0.02), transparent)',
                    }}
                  >
                    <Box sx={{ 
                      display: 'flex', 
                      justifyContent: 'center', 
                      alignItems: 'center',
                      opacity: 0.6
                    }}>
                      <Typography variant="caption" color="text.secondary">
                        {visibleCount < rows.length 
                          ? `Scroll for more... (${visibleCount}/${rows.length} visible)`
                          : `Scroll for more... (${rows.length}/${totalLength} loaded)`
                        }
                      </Typography>
                    </Box>
                  </TableCell>
                </TableRow>
              )}

              {/* ðŸ”¥ Enhanced "All data loaded" message - only show when all data is visible */}
              {visibleCount >= rows.length && visibleCount >= totalLength && rows.length >= totalLength && (
                <TableRow>
                  <TableCell colSpan={headCells.length + (serialNo ? 1 : 0) + (selectable ? 1 : 0)} align="center">
                    <Box sx={{ 
                      p: 4,
                      display: 'flex',
                      flexDirection: 'column',
                      alignItems: 'center',
                      gap: 2,
                      background: 'linear-gradient(135deg, rgba(76, 175, 80, 0.05) 0%, rgba(76, 175, 80, 0.02) 100%)',
                      borderRadius: 2,
                      margin: 1,
                      animation: 'slideUp 0.5s ease-out',
                      '@keyframes slideUp': {
                        '0%': { opacity: 0, transform: 'translateY(30px)' },
                        '100%': { opacity: 1, transform: 'translateY(0)' }
                      }
                    }}>
                      <Box
                        sx={{
                          width: 48,
                          height: 48,
                          borderRadius: '50%',
                          backgroundColor: 'success.main',
                          display: 'flex',
                          alignItems: 'center',
                          justifyContent: 'center',
                          animation: 'checkmark 0.6s ease-out 0.3s both',
                          '@keyframes checkmark': {
                            '0%': { transform: 'scale(0)', opacity: 0 },
                            '50%': { transform: 'scale(1.2)', opacity: 0.8 },
                            '100%': { transform: 'scale(1)', opacity: 1 }
                          }
                        }}
                      >
                        <Typography sx={{ color: 'white', fontSize: '1.5rem' }}>âœ“</Typography>
                      </Box>
                      <Typography 
                        variant="subtitle1" 
                        color="success.main"
                        sx={{ fontWeight: 600 }}
                      >
                        All records loaded successfully!
                      </Typography>
                      <Typography 
                        variant="body2" 
                        color="text.secondary"
                        sx={{ textAlign: 'center' }}
                      >
                        You've viewed all {totalLength} records
                      </Typography>
                    </Box>
                  </TableCell>
                </TableRow>
              )}

              {/* No data row */}
              {!loading && lengthOfData <= 0 && (
                <TableRow style={{ height: 53 * 5 }}>
                  <TableCell colSpan={headCells.length} sx={{ textAlign: "center" }}>
                    <NoData image="images/NoData.png" msgHead="No Data Available" />
                  </TableCell>
                </TableRow>
              )}

              {/* Loading spinner row */}
              {loading && rows.length <= 0 && (
                <TableRow sx={{ height: 53 * 3 }}>
                  <TableCell
                    colSpan={headCells.length + (serialNo ? 1 : 0) + (expandable ? 1 : 0)}
                    sx={{ textAlign: "center" }}
                  >
                    <CircularProgress />
                  </TableCell>
                </TableRow>
              )}

              {showTotal && (
                <TableRow>
                  <TableCell colSpan={totalColSpan} sx={{ pt: "1rem", pb: "1rem" }}>
                    <Typography>Total</Typography>
                  </TableCell>
                  {headCells.map((headCell, i) => {
                    if (headCell.numeric) {
                      return (
                        <TableCell key={i} sx={{ fontWeight: 700 }}>
                          {getSum(rows, headCell.id)}
                        </TableCell>
                      );
                    }
                    if (i !== 0) return <TableCell key={i} />;
                    return null;
                  })}
                  {expandIconAt === "end" && <TableCell />}
                </TableRow>
              )}
            </TableBody>
          </Table>
        </TableContainer>
      </Paper>
    </Box>
  );
};

ScrollableTable.defaultProps = {
  serialNo: false,
  selectable: false,
  expandIconAt: "start",
  uniqueKey: "id",
  actions: [],
  loading: false,
  deleteButton: false,
  selected: [],
};

export default ScrollableTable;
