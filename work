// Refactored ScrollableTable - Production Ready
import * as React from "react";
import ReactDOMServer from "react-dom/server";
import {
  Typography,
  Table,
  TableContainer,
  TableBody,
  TableRow,
  TableCell,
  Box,
  Paper,
  Checkbox,
  CircularProgress,
} from "@mui/material";
import styles from "./style.module.scss";
import { Order, PaginatedTableProps } from "./table.d";
import EnhancedTableHead from "./head";
import Row from "./collapsible_row";
import { getComparator, getSum, stableSort } from "./helpers";
import HtmlTable from "./html_table";
import NoData from "./NoData";
import { useRouter } from "next/router";

const ScrollableTable = (props: PaginatedTableProps) => {
  const [order, setOrder] = React.useState<Order>("asc");
  const [orderBy, setOrderBy] = React.useState<string>("");
  const [totalColSpan, setTotalColSpan] = React.useState<any>(0);
  const [htmlTable, setHtmlTable] = React.useState<any>("");
  const [isPrintClicked, setPrintClicked] = React.useState<boolean>(false);
  const [isExcelClicked, setExcelClicked] = React.useState<boolean>(false);
  const [expandedRowId, setExpandedRowId] = React.useState<string | null>(null);

  // Infinite scroll state
  const [visibleCount, setVisibleCount] = React.useState(10);
  const [isLocalLoading, setIsLocalLoading] = React.useState(false);
  
  // Refs
  const isMountedRef = React.useRef(true);
  const loaderRef = React.useRef<HTMLDivElement | null>(null);
  const tableContainerRef = React.useRef<HTMLDivElement | null>(null);
  const observerRef = React.useRef<IntersectionObserver | null>(null);
  const scrollPositionRef = React.useRef<number>(0);
  const isLoadingRef = React.useRef<boolean>(false);
  const lastLoadTimeRef = React.useRef<number>(0);

  const router = useRouter();
  const { locale } = router;

  const {
    expandable,
    expandInCols,
    serialNo,
    rows,
    headCells,
    expandIconAt,
    uniqueKey,
    actions,
    loading,
    tableRef,
    tableTitle,
    excelFileName,
    order: orderProps,
    orderBy: orderByProps,
    showTotal,
    selectable,
    selected,
    setSelected,
    viewlabel,
    coloumnNumber,
    agentNumber,
    hasMore = false,
    onLoadMore,
    totalLength,
    isLoadingMore = false,
    onScrollPositionChange,
  } = props;

  const lengthOfData = rows?.length || 0;

  // Save and restore scroll position functions
  const saveScrollPosition = React.useCallback(() => {
    if (tableContainerRef.current) {
      scrollPositionRef.current = tableContainerRef.current.scrollTop;
      console.log('Scroll position saved:', scrollPositionRef.current);
    }
  }, []);

  const restoreScrollPosition = React.useCallback(() => {
    if (tableContainerRef.current && scrollPositionRef.current > 0) {
      // Use RAF for smooth restoration after DOM updates
      requestAnimationFrame(() => {
        requestAnimationFrame(() => {
          if (tableContainerRef.current) {
            tableContainerRef.current.scrollTop = scrollPositionRef.current;
            console.log('Scroll position restored:', scrollPositionRef.current);
          }
        });
      });
    }
  }, []);

  // Expose scroll handlers to parent
  React.useEffect(() => {
    if (onScrollPositionChange) {
      onScrollPositionChange({
        saveScrollPosition,
        restoreScrollPosition
      });
    }
  }, [onScrollPositionChange, saveScrollPosition, restoreScrollPosition]);

  const handleToggleExpand = (rowId: string) => {
    setExpandedRowId(prev => (prev === rowId ? null : rowId));
  };

  // Colspan setup
  React.useEffect(() => {
    setTotalColSpan(
      1 +
        (selectable ? 1 : 0) +
        (serialNo ? 1 : 0) +
        (expandIconAt === "start" ? 1 : 0)
    );
  }, [showTotal, selectable, serialNo, expandIconAt]);

  // External order props
  React.useEffect(() => {
    if (orderProps) setOrder(orderProps);
  }, [orderProps]);

  React.useEffect(() => {
    if (orderByProps) setOrderBy(orderByProps);
  }, [orderByProps]);

  // Export logic
  React.useEffect(() => {
    if (headCells && rows.length > 0) {
      const htmlTableSample = ReactDOMServer.renderToString(
        <HtmlTable
          headCells={headCells}
          rows={rows}
          uniqueKey={`row-${uniqueKey}-${rows[0]}`}
          title={tableTitle}
        />
      );
      setHtmlTable(htmlTableSample);
    }
  }, [rows, headCells, uniqueKey, tableTitle]);

  const base64 = (s: any) => window.btoa(unescape(encodeURIComponent(s)));
  
  React.useEffect(() => {
    if (isPrintClicked) {
      const printWindow = window.open("", "", "width=800,height=600");
      if (printWindow) {
        printWindow.document.write(htmlTable);
        printWindow.document.close();
        setTimeout(() => {
          printWindow.focus();
          printWindow.print();
          setPrintClicked(false);
        }, 500);
      }
    }
  }, [isPrintClicked, htmlTable]);

  React.useEffect(() => {
    if (isExcelClicked) {
      const uri = "data:application/vnd.ms-excel;base64,";
      const template = `<html xmlns:o="urn:schemas-microsoft-com:office:office" 
        xmlns:x="urn:schemas-microsoft-com:office:excel" 
        xmlns="http://www.w3.org/TR/REC-html40">
        <head><meta http-equiv="content-type" content="text/plain; charset=UTF-8"/></head>
        <body>${htmlTable}</body></html>`;
      const a = window.document.createElement("a");
      a.href = uri + base64(template);
      a.download = `${excelFileName}.xls`;
      a.click();
      setExcelClicked(false);
    }
  }, [isExcelClicked, htmlTable, excelFileName]);

  const print = React.useCallback(() => setPrintClicked(true), []);
  const exportToExcel = React.useCallback(() => setExcelClicked(true), []);

  React.useEffect(() => {
    if (tableRef) {
      tableRef.current = { print, exportToExcel };
    }
  }, [tableRef, print, exportToExcel]);

  const handleRequestSort = (
    event: React.MouseEvent<unknown>,
    property: string
  ) => {
    const isAsc = orderBy === property && order === "asc";
    setOrder(isAsc ? "desc" : "asc");
    setOrderBy(property);
  };

  const handleSelectAllClick = (event: any) => {
    if (event.target.checked) {
      const newSelecteds = rows.map(n => n[uniqueKey].toString());
      setSelected && setSelected(newSelecteds);
      return;
    }
    setSelected && setSelected([]);
  };

  const handleClick = (event: React.MouseEvent<unknown>, name: string) => {
    const selectedIndex = selected.indexOf(name);
    let newSelected: readonly string[] = [];

    if (selectedIndex === -1) {
      newSelected = newSelected.concat(selected, name);
    } else if (selectedIndex === 0) {
      newSelected = newSelected.concat(selected.slice(1));
    } else if (selectedIndex === selected.length - 1) {
      newSelected = newSelected.concat(selected.slice(0, -1));
    } else if (selectedIndex > 0) {
      newSelected = newSelected.concat(
        selected?.slice(0, selectedIndex),
        selected?.slice(selectedIndex + 1)
      );
    }
    setSelected && setSelected(newSelected);
  };

  const isSelected = (name: string) => selected.includes(name);

  // Enhanced load more handler with proper debouncing
  const handleLoadMoreData = React.useCallback(() => {
    // Prevent multiple simultaneous loads
    if (isLoadingRef.current || isLoadingMore) {
      console.log('Load blocked: already loading');
      return;
    }

    const now = Date.now();
    // Throttle requests to once per second
    if (now - lastLoadTimeRef.current < 1000) {
      console.log('Load blocked: throttled');
      return;
    }

    const canShowMore = visibleCount < rows.length;
    const canFetchMore = rows.length < totalLength && hasMore && onLoadMore;

    if (!canShowMore && !canFetchMore) {
      console.log('Load blocked: no more data');
      return;
    }

    console.log('Loading more:', { canShowMore, canFetchMore, visibleCount, rowsLength: rows.length });

    if (canShowMore) {
      // Show more existing data
      isLoadingRef.current = true;
      setIsLocalLoading(true);
      lastLoadTimeRef.current = now;

      setTimeout(() => {
        if (isMountedRef.current) {
          setVisibleCount(prev => {
            const newCount = Math.min(prev + 10, rows.length);
            
            // Only trigger server fetch when ALL loaded data is shown
            if (newCount >= rows.length && rows.length < totalLength && hasMore && onLoadMore) {
              console.log('All data shown, triggering server fetch');
              setTimeout(() => {
                if (isMountedRef.current && !isLoadingMore) {
                  onLoadMore();
                }
              }, 100);
            }
            
            return newCount;
          });
          
          setIsLocalLoading(false);
          isLoadingRef.current = false;
        }
      }, 200);
    } else if (canFetchMore) {
      // Trigger server fetch
      console.log('Triggering server fetch');
      isLoadingRef.current = true;
      lastLoadTimeRef.current = now;
      onLoadMore();
      
      // Reset loading flag after delay
      setTimeout(() => {
        if (isMountedRef.current) {
          isLoadingRef.current = false;
        }
      }, 1000);
    }
  }, [visibleCount, rows.length, totalLength, hasMore, onLoadMore, isLoadingMore]);

  // Enhanced intersection observer with proper cleanup
  React.useEffect(() => {
    // Clean up existing observer
    if (observerRef.current) {
      observerRef.current.disconnect();
      observerRef.current = null;
    }

    if (typeof window === "undefined" || !("IntersectionObserver" in window)) {
      return;
    }

    if (!loaderRef.current || !onLoadMore) {
      return;
    }

    const observer = new IntersectionObserver(
      (entries) => {
        const target = entries[0];
        if (target.isIntersecting && isMountedRef.current) {
          handleLoadMoreData();
        }
      },
      { 
        threshold: 0.1,
        rootMargin: '100px'
      }
    );

    observerRef.current = observer;
    observer.observe(loaderRef.current);

    return () => {
      if (observerRef.current) {
        observerRef.current.disconnect();
        observerRef.current = null;
      }
    };
  }, [handleLoadMoreData, onLoadMore]);

  // Reset visible count when filters change (rows reset)
  React.useEffect(() => {
    if (rows.length > 0 && rows.length < visibleCount) {
      console.log('Resetting visible count to match new data');
      setVisibleCount(Math.min(10, rows.length));
      isLoadingRef.current = false;
    }
  }, [rows.length]);

  // Auto-adjust visible count when new data loads
  React.useEffect(() => {
    if (rows.length > visibleCount && !isLoadingMore) {
      // New data was loaded, adjust visible count
      const newVisible = Math.min(visibleCount + 10, rows.length);
      if (newVisible !== visibleCount) {
        console.log('Auto-adjusting visible count:', newVisible);
        setVisibleCount(newVisible);
      }
    }
  }, [rows.length, isLoadingMore]);

  // Handle scroll events
  const handleScroll = React.useCallback((event: React.UIEvent<HTMLDivElement>) => {
    const target = event.currentTarget;
    scrollPositionRef.current = target.scrollTop;
  }, []);

  // Restore scroll after data changes
  React.useEffect(() => {
    if (scrollPositionRef.current > 0 && !loading && !isLoadingMore) {
      restoreScrollPosition();
    }
  }, [rows.length, loading, isLoadingMore, restoreScrollPosition]);

  // Cleanup on unmount
  React.useEffect(() => {
    return () => {
      isMountedRef.current = false;
      if (observerRef.current) {
        observerRef.current.disconnect();
      }
    };
  }, []);

  const visibleRows = React.useMemo(
    () => stableSort(rows, getComparator(order, orderBy)).slice(0, visibleCount),
    [rows, order, orderBy, visibleCount]
  );

  const showLoadingIndicator = isLoadingMore || isLocalLoading;
  const canLoadMore = visibleCount < rows.length || (hasMore && rows.length < totalLength);

  return (
    <Box sx={{ width: "100%", position: 'relative' }}>
      {/* Loading progress bar */}
      {showLoadingIndicator && (
        <Box
          sx={{
            position: 'absolute',
            top: 0,
            left: 0,
            right: 0,
            height: 3,
            zIndex: 1000,
            background: 'linear-gradient(90deg, transparent, #1976d2, transparent)',
            animation: 'slideProgress 1.5s ease-in-out infinite',
            '@keyframes slideProgress': {
              '0%': { transform: 'translateX(-100%)' },
              '100%': { transform: 'translateX(100%)' }
            }
          }}
        />
      )}

      <Paper
        elevation={2}
        sx={{
          borderRadius: ".5rem",
          boxShadow: "none",
          border: "1px solid #ECECEC",
          position: 'relative',
          overflow: 'hidden'
        }}
      >
        <TableContainer 
          ref={tableContainerRef}
          onScroll={handleScroll}
          sx={{ 
            maxHeight: '70vh', 
            overflow: 'auto',
            scrollBehavior: 'auto',
            position: 'relative',
            '&::-webkit-scrollbar': { width: '8px' },
            '&::-webkit-scrollbar-track': { background: '#f1f1f1', borderRadius: '4px' },
            '&::-webkit-scrollbar-thumb': { 
              background: '#c1c1c1', 
              borderRadius: '4px',
              '&:hover': { background: '#a8a8a8' }
            }
          }}
        >
          <Table sx={{ minWidth: 750 }} size="small" stickyHeader>
            <EnhancedTableHead
              order={order}
              orderBy={orderBy}
              onRequestSort={handleRequestSort}
              headCells={headCells}
              serialNo={serialNo}
              expandIconAt={expandIconAt}
              selectable={selectable}
              onSelectAllClick={handleSelectAllClick}
              numSelected={selected?.length}
              rowCount={lengthOfData}
              viewlabel={viewlabel}
              sx={{
                '& .MuiTableCell-head': {
                  backgroundColor: '#ffffff',
                  backdropFilter: 'blur(10px)',
                  borderBottom: '2px solid #e0e0e0',
                  fontWeight: 600,
                  fontSize: '0.875rem',
                  color: 'text.primary',
                  position: 'sticky',
                  top: 0,
                  zIndex: 1100,
                  boxShadow: '0 2px 4px rgba(0,0,0,0.1)',
                }
              }}
            />
            <TableBody>
              {/* Record counter */}
              <TableRow>
                <TableCell 
                  colSpan={headCells.length + (serialNo ? 1 : 0) + (selectable ? 1 : 0)} 
                  sx={{ 
                    backgroundColor: 'rgba(255, 255, 255, 0.95)',
                    backdropFilter: 'blur(8px)',
                    fontWeight: 500,
                    fontSize: '0.875rem',
                    textAlign: 'center',
                    padding: '12px',
                    borderBottom: '2px solid rgba(25, 118, 210, 0.1)',
                    position: 'sticky',
                    top: 56,
                    zIndex: 1000,
                    boxShadow: '0 1px 3px rgba(0,0,0,0.08)',
                  }}
                >
                  <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                    <Typography variant="body2" color="primary.main">
                      Showing {Math.min(visibleCount, rows.length)} of {rows.length} loaded
                    </Typography>
                    <Typography variant="body2" color="text.secondary">
                      {rows.length} / {totalLength || rows.length} total records
                    </Typography>
                  </Box>
                </TableCell>
              </TableRow>

              {/* Table rows */}
              {visibleRows.map((row, index) => {
                const isItemSelected = isSelected(row[uniqueKey]?.toString());
                return expandable ? (
                  <Row
                    key={row[uniqueKey]}
                    expandedRowId={expandedRowId}
                    onToggleExpand={handleToggleExpand}
                    row={row}
                    agentNumber={agentNumber}
                    headCells={headCells}
                    expand={expandable}
                    expandInCols={expandInCols}
                    expandIconAt={expandIconAt}
                    serialNo={serialNo ? index + 1 : undefined}
                    coloumnNumber={coloumnNumber}
                    selectable={
                      selectable && (
                        <TableCell
                          className={styles.stickyLeft}
                          padding="checkbox"
                          sx={{ p: "1rem", left: 0, textAlign: "center" }}
                        >
                          <Checkbox
                            color="primary"
                            checked={isItemSelected}
                            onClick={event =>
                              handleClick(event, row[uniqueKey].toString())
                            }
                          />
                        </TableCell>
                      )
                    }
                  />
                ) : (
                  <TableRow 
                    key={row[uniqueKey]}
                    sx={{
                      '&:hover': {
                        backgroundColor: 'rgba(25, 118, 210, 0.04)',
                        transition: 'background-color 0.2s ease'
                      }
                    }}
                  >
                    {selectable && (
                      <TableCell padding="checkbox" sx={{ p: "1rem" }}>
                        <Checkbox
                          color="primary"
                          checked={isItemSelected}
                          onClick={event =>
                            handleClick(event, row[uniqueKey].toString())
                          }
                        />
                      </TableCell>
                    )}
                    {serialNo && <TableCell>{index + 1}</TableCell>}
                    {headCells.map(headCell => (
                      <TableCell
                        key={headCell.id}
                        className={
                          headCell.stickyClass ? styles[headCell.stickyClass] : ""
                        }
                        sx={{
                          fontSize: "0.875rem",
                          left: headCell.stickyAt,
                          right: headCell.stickyAt,
                        }}
                      >
                        {headCell.cell ? headCell.cell(row) : row[headCell.id]}
                      </TableCell>
                    ))}
                  </TableRow>
                );
              })}

              {/* Loading indicator */}
              {showLoadingIndicator && (
                <TableRow>
                  <TableCell colSpan={headCells.length + (serialNo ? 1 : 0) + (selectable ? 1 : 0)} align="center">
                    <Box sx={{ 
                      p: 3,
                      display: 'flex',
                      flexDirection: 'column',
                      alignItems: 'center',
                      gap: 1.5,
                      background: 'linear-gradient(135deg, rgba(25, 118, 210, 0.05) 0%, rgba(25, 118, 210, 0.02) 100%)',
                      borderRadius: 2,
                      margin: 1,
                    }}>
                      <CircularProgress size={32} thickness={3} />
                      <Typography variant="body2" color="primary.main" sx={{ fontWeight: 500 }}>
                        Loading next 10 records...
                      </Typography>
                    </Box>
                  </TableCell>
                </TableRow>
              )}

              {/* Sentinel for infinite scroll */}
              {canLoadMore && !showLoadingIndicator && (
                <TableRow ref={loaderRef}>
                  <TableCell 
                    colSpan={headCells.length + (serialNo ? 1 : 0) + (selectable ? 1 : 0)}
                    sx={{ height: '40px', background: 'linear-gradient(to bottom, transparent, rgba(25, 118, 210, 0.02), transparent)' }}
                  >
                    <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', opacity: 0.6 }}>
                      <Typography variant="caption" color="text.secondary">
                        {visibleCount < rows.length 
                          ? `Scroll for more... (${visibleCount}/${rows.length} visible)`
                          : `Scroll for more... (${rows.length}/${totalLength} loaded)`
                        }
                      </Typography>
                    </Box>
                  </TableCell>
                </TableRow>
              )}

              {/* All data loaded message */}
              {visibleCount >= rows.length && visibleCount >= totalLength && rows.length >= totalLength && (
                <TableRow>
                  <TableCell colSpan={headCells.length + (serialNo ? 1 : 0) + (selectable ? 1 : 0)} align="center">
                    <Box sx={{ 
                      p: 4,
                      display: 'flex',
                      flexDirection: 'column',
                      alignItems: 'center',
                      gap: 2,
                      background: 'linear-gradient(135deg, rgba(76, 175, 80, 0.05) 0%, rgba(76, 175, 80, 0.02) 100%)',
                      borderRadius: 2,
                      margin: 1,
                    }}>
                      <Box sx={{
                        width: 48,
                        height: 48,
                        borderRadius: '50%',
                        backgroundColor: 'success.main',
                        display: 'flex',
                        alignItems: 'center',
                        justifyContent: 'center',
                      }}>
                        <Typography sx={{ color: 'white', fontSize: '1.5rem' }}>✓</Typography>
                      </Box>
                      <Typography variant="subtitle1" color="success.main" sx={{ fontWeight: 600 }}>
                        All records loaded successfully!
                      </Typography>
                      <Typography variant="body2" color="text.secondary" sx={{ textAlign: 'center' }}>
                        You've viewed all {totalLength} records
                      </Typography>
                    </Box>
                  </TableCell>
                </TableRow>
              )}

              {/* No data */}
              {!loading && lengthOfData <= 0 && (
                <TableRow style={{ height: 53 * 5 }}>
                  <TableCell colSpan={headCells.length} sx={{ textAlign: "center" }}>
                    <NoData image="images/NoData.png" msgHead="No Data Available" />
                  </TableCell>
                </TableRow>
              )}

              {/* Initial loading */}
              {loading && rows.length <= 0 && (
                <TableRow sx={{ height: 53 * 3 }}>
                  <TableCell
                    colSpan={headCells.length + (serialNo ? 1 : 0) + (expandable ? 1 : 0)}
                    sx={{ textAlign: "center" }}
                  >
                    <CircularProgress />
                  </TableCell>
                </TableRow>
              )}

              {/* Total row */}
              {showTotal && (
                <TableRow>
                  <TableCell colSpan={totalColSpan} sx={{ pt: "1rem", pb: "1rem" }}>
                    <Typography>Total</Typography>
                  </TableCell>
                  {headCells.map((headCell, i) => {
                    if (headCell.numeric) {
                      return (
                        <TableCell key={i} sx={{ fontWeight: 700 }}>
                          {getSum(rows, headCell.id)}
                        </TableCell>
                      );
                    }
                    if (i !== 0) return <TableCell key={i} />;
                    return null;
                  })}
                  {expandIconAt === "end" && <TableCell />}
                </TableRow>
              )}
            </TableBody>
          </Table>
        </TableContainer>
      </Paper>
    </Box>
  );
};

ScrollableTable.defaultProps = {
  serialNo: false,
  selectable: false,
  expandIconAt: "start",
  uniqueKey: "id",
  actions: [],
  loading: false,
  deleteButton: false,
  selected: [],
};

export default ScrollableTable;
